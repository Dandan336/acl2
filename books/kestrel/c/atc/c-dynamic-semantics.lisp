; C Library
;
; Copyright (C) 2020 Kestrel Institute (http://www.kestrel.edu)
;
; License: A 3-clause BSD license. See the LICENSE file distributed with ACL2.
;
; Author: Alessandro Coglio (coglio@kestrel.edu)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package "C")

(include-book "c-abstract-syntax")
(include-book "c-integers")

(include-book "kestrel/fty/defflatsum" :dir :system)
(include-book "kestrel/fty/defomap" :dir :system)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defxdoc+ atc-c-dynamic-semantics
  :parents (atc)
  :short "A dynamic semantics of C for ATC."
  :long
  (xdoc::topstring
   (xdoc::p
    "In order to support the generation of proofs for
     the C code generated by ATC,
     we need a dynamic (i.e. execution) semantics
     of (the needed portion of) C.
     The dynamic semantics serves to prove that
     the generated C code is funtionally equivalent to
     the ACL2 code from which it is generated.
     Here we provide an initial formal dynamic semantics,
     which should support the generation of proofs
     for an initial version of ATC.")
   (xdoc::p
    "This preliminary dynamic semantics may be extended in the future,
     and may be replaced by a more comprehensive model
     that we will be developing as part of the "
    (xdoc::seetopic "language" "language formalization")
    ".")
   (xdoc::p
    "The dynamic semantics is defined over the C abstract syntax,
     but for now it does not support the execution of many constructs,
     just because ATC does not generate those constructs for now.
     This way, we keep the dynamic semantics simpler.
     Being too restrictive is adequate here:
     if we have a prove of functional equivalence between some ACL2 code
     and some C code according to this restriction dynamic semantics,
     it means that the C code only uses the constructs that we cover,
     which is a subset of valid C."))
  :order-subtopics t
  :default-parent t)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(fty::defprod error
  :short "Fixtype of errors."
  :long
  (xdoc::topstring
   (xdoc::p
    "We formalize a defensive dynamic semantics
     that returns error indications when any defensive check fails,
     such as the fact that the operand of an operation has the right type.")
   (xdoc::p
    "In order to be flexible in the kind of error information we return,
     we define this fixtype as a wrapper of any ACL2 value."))
  ((info acl2::any))
  :pred errorp)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(fty::defflatsum value-result
  :short "Fixtype of values and errors."
  (:ok sint)
  (:err error)
  :pred value-resultp)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(fty::defoption maybe-value
  sint
  :short "Fixtype of optional values."
  :pred maybe-valuep)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(fty::deflist value-list
  :short "Fixtype of lists of values."
  :elt-type sint
  :true-listp t
  :elementp-of-nil nil
  :pred value-listp)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(encapsulate ()

  (local (in-theory (enable sintp)))

  (fty::defflatsum maybe-value-result
    :short "Fixtype of optional values and errors."
    (:ok maybe-value)
    (:err error)
    :pred maybe-value-resultp))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(fty::defomap store
  :short "Fixtype of variable stores."
  :long
  (xdoc::topstring
   (xdoc::p
    "A variable store is a finite map from identifiers to @('int') values
     (for now these are the only values that we model).
     It represents the contents of the variables in scope."))
  :key-type ident
  :val-type sint
  :pred storep)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(fty::defflatsum store-result
  :short "Fixtype of stores and errors."
  (:ok store)
  (:err error)
  :pred store-resultp)

;;;;;;;;;;;;;;;;;;;;

(defruled storep-when-store-resultp-ok
  (implies (and (store-resultp store)
                (store-result-case store :ok))
           (storep store))
  :enable (store-resultp
           store-result-kind))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define exec-iconst ((ic iconstp))
  :returns (result value-resultp)
  :short "Execute an integer constant."
  :long
  (xdoc::topstring
   (xdoc::p
    "We only support the execution of
     signed integer constants without type suffix.
     The value must be representable as an @('int').
     The base is ignored; the value is already a number.
     We return the value, as an @('int')."))
  (b* ((ic (iconst-fix ic))
       ((iconst ic) ic)
       ((when ic.unsignedp)
        (error (list :exec-iconst-unsigned ic)))
       ((unless (iconst-tysuffix-case ic.type :none))
        (error (list :exec-iconst-long/llong ic)))
       ((unless (acl2::sbyte32p ic.value))
        (error (list :exec-iconst-too-large ic))))
    (sint ic.value))
  :hooks (:fix))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define exec-const ((c constp))
  :returns (result value-resultp)
  :short "Execute a constant."
  :long
  (xdoc::topstring
   (xdoc::p
    "We only support the execution of integer constants."))
  (const-case c
              :int (exec-iconst c.get)
              :float (error :exec-const-float)
              :enum (error :exec-const-enum)
              :char (error :exec-const-char))
  :hooks (:fix))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define exec-ident ((id identp) (store storep))
  :returns (result value-resultp)
  :short "Execute a variable."
  :long
  (xdoc::topstring
   (xdoc::p
    "The execution of expressions takes place in the context of a store.
     We look up the variable's value in the store,
     defensively returning an error if the variable is not in the store,
     which means that the variable is not in scope."))
  (b* ((id (ident-fix id))
       (store (store-fix store))
       (pair? (omap::in id store))
       ((when (not pair?)) (error (list :exec-ident-not-in-scope id))))
    (cdr pair?))
  :hooks (:fix))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define exec-unary ((op unopp) (arg value-resultp))
  :returns (result value-resultp)
  :short "Execute a unary expression."
  :long
  (xdoc::topstring
   (xdoc::p
    "The argument is the result of
     recursively executing the operand expression.
     For now we only support some unary operators."))
  (b* ((op (unop-fix op))
       (arg (value-result-fix arg)))
    (value-result-case
     arg
     :err arg.get
     :ok (unop-case
          op
          :plus (sint-plus arg.get)
          :minus (if (sint-minus-okp arg.get)
                     (sint-minus arg.get)
                   (error (list :exec-unary op arg)))
          :bitnot (sint-bitnot arg.get)
          :lognot (sint-lognot arg.get))))
  :hooks (:fix))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define exec-binary ((op binopp) (arg1 value-resultp) (arg2 value-resultp))
  :returns (result value-resultp)
  :short "Execute a binary expression."
  :long
  (xdoc::topstring
   (xdoc::p
    "The arguments are the results of
     recursively executing the operand expressions.
     For now we only support some binary operators."))
  (b* ((op (binop-fix op))
       (arg1 (value-result-fix arg1))
       (arg2 (value-result-fix arg2)))
    (if (value-result-case arg1 :ok)
        (if (value-result-case arg2 :ok)
            (binop-case
             op
             :mul (if (sint-mul-okp arg1 arg2)
                      (sint-mul arg1 arg2)
                    (error (list :exec-binary op arg1 arg2)))
             :div (if (sint-div-okp arg1 arg2)
                      (sint-div arg1 arg2)
                    (error (list :exec-binary op arg1 arg2)))
             :rem (if (sint-rem-okp arg1 arg2)
                      (sint-rem arg1 arg2)
                    (error (list :exec-binary op arg1 arg2)))
             :add (if (sint-add-okp arg1 arg2)
                      (sint-add arg1 arg2)
                    (error (list :exec-binary op arg1 arg2)))
             :sub (if (sint-sub-okp arg1 arg2)
                      (sint-sub arg1 arg2)
                    (error (list :exec-binary op arg1 arg2)))
             :shl (if (sint-shl-sint-okp arg1 arg2)
                      (sint-shl-sint arg1 arg2)
                    (error (list :exec-binary op arg1 arg2)))
             :shr (if (sint-shr-sint-okp arg1 arg2)
                      (sint-shr-sint arg1 arg2)
                    (error (list :exec-binary op arg1 arg2)))
             :lt (sint-lt arg1 arg2)
             :gt (sint-gt arg1 arg2)
             :le (sint-le arg1 arg2)
             :ge (sint-ge arg1 arg2)
             :eq (sint-eq arg1 arg2)
             :ne (sint-ne arg1 arg2)
             :bitand (sint-bitand arg1 arg2)
             :bitxor (sint-bitxor arg1 arg2)
             :bitior (sint-bitior arg1 arg2)
             :logand (error (list :exec-binary op arg1 arg2))
             :logor (error (list :exec-binary op arg1 arg2))
             :asg (error (list :exec-binary op arg1 arg2))
             :asg-mul (error (list :exec-binary op arg1 arg2))
             :asg-div (error (list :exec-binary op arg1 arg2))
             :asg-rem (error (list :exec-binary op arg1 arg2))
             :asg-add (error (list :exec-binary op arg1 arg2))
             :asg-sub (error (list :exec-binary op arg1 arg2))
             :asg-shl (error (list :exec-binary op arg1 arg2))
             :asg-shr (error (list :exec-binary op arg1 arg2))
             :asg-and (error (list :exec-binary op arg1 arg2))
             :asg-xor (error (list :exec-binary op arg1 arg2))
             :asg-ior (error (list :exec-binary op arg1 arg2)))
          arg2)
      (if (value-result-case arg2 :ok)
          arg1
        (error (list :exec-binary op arg1 arg2)))))
  :guard-hints (("Goal" :in-theory (enable value-result-kind)))
  :hooks (:fix))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define exec-expr ((e exprp) (store storep))
  :returns (result value-resultp)
  :verify-guards :after-returns
  :short "Execute an expression."
  :long
  (xdoc::topstring
   (xdoc::p
    "For now we only support the execution of
     variables, (some) constants, and (some) unary and binary expressions."))
  (b* ((e (expr-fix e)))
    (expr-case
     e
     :ident (exec-ident e.get store)
     :const (exec-const e.get)
     :call (error (list :exec-expr e))
     :postinc (error (list :exec-expr e))
     :postdec (error (list :exec-expr e))
     :preinc (error (list :exec-expr e))
     :predec (error (list :exec-expr e))
     :unary (b* ((arg (exec-expr e.arg store)))
              (exec-unary e.op arg))
     :cast (error (list :exec-expr e))
     :binary (b* ((arg1 (exec-expr e.arg1 store))
                  (arg2 (exec-expr e.arg2 store)))
               (exec-binary e.op arg1 arg2))
     :cond (b* ((test (exec-expr e.test store)))
             (value-result-case test
                                :ok (if (sint-nonzerop test.get)
                                        (exec-expr e.then store)
                                      (exec-expr e.else store))
                                :err test.get))))
  :measure (expr-count e)
  :hooks (:fix))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defines exec-stmt-fns
  :short "Execute a statement."
  :long
  (xdoc::topstring
   (xdoc::p
    "For now we only support the execution of @('return') statements.
     If there is no expression, no value is returned.
     If there is an expression, its value is returned.
     We also support the execution of compound statments
     that consists of supported statements."))

  (define exec-stmt ((s stmtp) (store storep))
    :returns (result maybe-value-resultp)
    :parents nil
    (b* ((s (stmt-fix s)))
      (stmt-case
       s
       :labeled (error (list :exec-stmt s))
       :compound (exec-block-item-list s.items store)
       :expr (error (list :exec-stmt s))
       :null (error (list :exec-stmt s))
       :if (b* ((test (exec-expr s.test store)))
             (value-result-case test
                                :ok (if (sint-nonzerop test.get)
                                        (exec-stmt s.then store)
                                      nil)
                                :err test.get))
       :ifelse (b* ((test (exec-expr s.test store)))
                 (value-result-case test
                                    :ok (if (sint-nonzerop test.get)
                                            (exec-stmt s.then store)
                                          (exec-stmt s.else store))
                                    :err test.get))
       :switch (error (list :exec-stmt s))
       :while (error (list :exec-stmt s))
       :dowhile (error (list :exec-stmt s))
       :for (error (list :exec-stmt s))
       :goto (error (list :exec-stmt s))
       :continue (error (list :exec-stmt s))
       :break (error (list :exec-stmt s))
       :return (if (exprp s.value)
                   (b* ((eres (exec-expr s.value store)))
                     (value-result-case
                      eres
                      :err eres.get
                      :ok eres.get))
                 nil)))
    :measure (stmt-count s))

  (define exec-block-item ((item block-itemp) (store storep))
    :returns (result maybe-value-resultp)
    :parents nil
    (block-item-case item
                     :decl (error (list :exec-block-item item.get))
                     :stmt (exec-stmt item.get store))
    :measure (block-item-count item))

  (define exec-block-item-list ((items block-item-listp) (store storep))
    :returns (result maybe-value-resultp)
    :parents nil
    (b* (((when (endp items)) nil)
         (val? (exec-block-item (car items) store))
         ((when (maybe-value-result-case val? :err)) val?)
         ((when val?) val?))
      (exec-block-item-list (cdr items) store))
    :measure (block-item-list-count items))

  :verify-guards nil ; done below
  ///
  (verify-guards exec-stmt)

  (fty::deffixequiv-mutual exec-stmt-fns))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define lookup-fun ((fun identp) (tunit transunitp))
  :returns (fundef? maybe-fundefp)
  :short "Look up a function definition by name."
  :long
  (xdoc::topstring
   (xdoc::p
    "In well-formed translation units,
     function definitions have unique names.
     We return the first matching function definition, if any,
     as it is the only one with that name."))
  (lookup-fun-aux fun (transunit->decls tunit))
  :hooks (:fix)

  :prepwork
  ((define lookup-fun-aux ((fun identp) (decls ext-decl-listp))
     :returns (fundef? maybe-fundefp)
     (b* (((when (endp decls)) nil)
          (decl (car decls))
          ((when (and (ext-decl-case decl :fundef)
                      (ident-equiv fun
                                   (fundef->name (ext-decl-fundef->get decl)))))
           (ext-decl-fundef->get decl)))
       (lookup-fun-aux fun (cdr decls)))
     :hooks (:fix))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define init-store ((formals param-decl-listp) (actuals value-listp))
  :returns (result store-resultp)
  :short "Initialize the store for a function call."
  :long
  (xdoc::topstring
   (xdoc::p
    "We go through formal parameters and actual arguments,
     pairing them up into the store.
     We return an error if they do not match in number,
     or if there are repeated parameters."))
  (b* ((formals (param-decl-list-fix formals))
       (actuals (value-list-fix actuals))
       ((when (endp formals))
        (if (endp actuals)
            nil
          (error (list :init-store :extra-actuals actuals))))
       ((when (endp actuals))
        (error (list :init-store :extra-formals formals)))
       (store (init-store (cdr formals) (cdr actuals))))
    (store-result-case
     store
     :err store.get
     :ok (b* ((formal (car formals))
              (actual (car actuals))
              (name (param-decl->name formal)))
           (if (omap::in name store)
               (error (list :init-store :duplicate-param name))
             (omap::update name actual store)))))
  :hooks (:fix)
  :measure (len formals)
  :prepwork ((local (in-theory (enable storep-when-store-resultp-ok))))
  :verify-guards nil
  ///
  (verify-guards init-store))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define exec-fun ((fun identp) (args value-listp) (tunit transunitp))
  :returns (result value-resultp)
  :short "Execute a function call."
  :long
  (xdoc::topstring
   (xdoc::p
    "We look up the function definition in the translation unit.
     We build the initial store and we execute the function body.
     We ensure that a value is returned."))
  (b* ((fun (ident-fix fun))
       (fundef (lookup-fun fun tunit))
       ((when (not fundef)) (error (list :exec-fun :undefined fun)))
       ((fundef fundef) fundef)
       (store (init-store (fundef->params fundef) args)))
    (store-result-case
     store
     :err store.get
     :ok (b* ((val? (exec-stmt fundef.body store.get)))
           (maybe-value-result-case
            val?
            :err val?.get
            :ok (if (not val?.get)
                    (error (list :exec-fun :no-value-returned))
                  val?.get)))))
  :hooks (:fix))
