; Standard Utilities Library
;
; Copyright (C) 2020 Kestrel Institute (http://www.kestrel.edu)
;
; License: A 3-clause BSD license. See the LICENSE file distributed with ACL2.
;
; Author: Alessandro Coglio (coglio@kestrel.edu)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package "ACL2")

(include-book "kestrel/event-macros/applicability-conditions" :dir :system)
(include-book "kestrel/event-macros/input-processing" :dir :system)
(include-book "kestrel/event-macros/restore-output" :dir :system)
(include-book "kestrel/event-macros/xdoc-constructors" :dir :system)
(include-book "kestrel/std/system/conjoin-equalities" :dir :system)
(include-book "kestrel/std/system/make-mv-let-call" :dir :system)
(include-book "kestrel/std/system/make-mv-nth-calls" :dir :system)
(include-book "kestrel/std/system/pseudo-event-form-listp" :dir :system)
(include-book "kestrel/utilities/defthmr" :dir :system)
(include-book "kestrel/utilities/error-checking/top" :dir :system)
(include-book "std/typed-alists/symbol-symbol-alistp" :dir :system)
(include-book "std/util/defaggregate" :dir :system)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(xdoc::evmac-topic-implementation

 defsurj

 :item-state t

 :item-wrld t

 :item-ctx t

 :items

 ("@('name'),
   @('doma'),
   @('domb'),
   @('alpha'),
   @('beta'),
   @('guard-thms'),
   @('thm-names'),
   @('hints'),
   @('print'), and
   @('show-only')
   are the homonymous inputs to @(tsee defsurj),
   before being validated.
   These variables have no types because they may be any values."

  "@('name$'),
   @('doma$'),
   @('domb$'),
   @('alpha$'),
   @('beta$'),
   @('guard-thms$'),
   @('thm-name$'),
   @('hints$'),
   @('print$'), and
   @('show-only$')
   are the results of processing
   the homonymous inputs (without the @('$')) to @(tsee defsurj).
   Some are identical to the corresponding inputs,
   but they have types implied by their successful validation,
   performed when they are processed."

  "@('call') is the call to @(tsee defsurj) supplied by the user."

  "@('call$') is the result of removing
   @(':print') and @(':show-only') from @('call')."

  "@('expansion') is the @(tsee encapsulate) generated by @(tsee defsurj)."

  "@('a1...an') is the list of variables @('a1'), ..., @('an')
   described in the documentation."

  "@('b1...bm') is the list of variables @('b1'), ..., @('bm')
   described in the documentation."))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defxdoc+ defsurj-table
  :parents (defsurj-implementation)
  :short "@(csee table) of recorded @(tsee defsurj) information."
  :long
  (xdoc::topstring
   (xdoc::p
    "For each successful call to @(tsee defsurj)
     whose @(':show-only') input is not @('t'),
     this table includes a pair
     whose key is the name supplied as first input to @(tsee defsurj)
     and whose value includes the information about
     the domains, conversions, and theorems
     (see @(tsee defsurj-infop)).")
   (xdoc::p
    "This table is used
     not only to record the @(tsee defsurj) information,
     but also to support the redundancy check
     in @(tsee defsurj-check-redundancy)."))
  :order-subtopics t
  :default-parent t)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defval *defsurj-table-name*
  'defsurj-table
  :short "Name of the @(tsee defsurj) table.")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(std::defaggregate defsurj-info
  :short "Information about a @(tsee defsurj) call,
          recorded as a pair's value in the @(tsee defsurj) table."
  ((call$ "The call to @(tsee defsurj),
           without @(':print') and @(':show-only')."
          pseudo-event-formp)
   (expansion "The @(tsee encapsulate) generated from
               the call to @(tsee defsurj)."
              pseudo-event-formp)
   (doma "Domain @($A$), in translated form." pseudo-termfnp)
   (domb "Domain @($B$), in translated form." pseudo-termfnp)
   (alpha "Conversion @($\\alpha$), in translated form." pseudo-termfnp)
   (beta "Conversion @($\\beta$), in translated form." pseudo-termfnp)
   (alpha-image "Name of the @(':alpha-image') theorem." symbolp)
   (beta-image "Name of the @(':beta-image') theorem." symbolp)
   (alpha-of-beta "Name of the @(':alpha-of-beta') theorem." symbolp)
   (doma-guard
    "Name of the @(':doma-guard') theorem, if present (otherwise @('nil'))."
    symbolp)
   (domb-guard
    "Name of the @(':domb-guard') theorem, if present (otherwise @('nil'))."
    symbolp)
   (alpha-guard
    "Name of the @(':alpha-guard') theorem, if present (otherwise @('nil'))."
    symbolp)
   (beta-guard
    "Name of the @(':beta-guard') theorem, if present (otherwise @('nil'))."
    symbolp))
  :pred defsurj-infop)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(make-event
 `(table ,*defsurj-table-name* nil nil
    :guard (and (symbolp key) ; NAME input of DEFSURJ
                (defsurj-infop val))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define maybe-defsurj-infop (x)
  :returns (yes/no booleanp)
  (or (defsurj-infop x)
      (eq x nil)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defsurj-lookup ((name symbolp) (wrld plist-worldp))
  :returns (info? "A @(tsee maybe-defsurj-infop).")
  :verify-guards nil
  :short "Return the information for the @(tsee defsurj) specified by name,
          or @('nil') if there is no @(tsee defsurj) with that name."
  (b* ((defsurj-table (table-alist *defsurj-table-name* wrld))
       (pair? (assoc-eq name defsurj-table))
       ((when (null pair?)) nil)
       (info (cdr pair?)))
    info))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defsurj-filter-call ((call pseudo-event-formp))
  :guard (and (>= (len call) 6)
              (eq 'defsurj (car call)))
  :returns (call$ "A @(tsee pseudo-event-formp).")
  :verify-guards nil
  :short "Remove any @(':print') and @(':show-only') inputs
          from a call to @(tsee defsurj)."
  :long
  (xdoc::topstring-p
   "As explained in the documentation,
    these two options are ignored when checking redundancy.")
  (b* ((number-of-required-args 5)
       (number-of-elements-before-options (1+ number-of-required-args))
       (options (nthcdr number-of-elements-before-options call))
       (options (remove-keyword :print options))
       (options (remove-keyword :show-only options))
       (call$ (append (take number-of-elements-before-options call) options)))
    call$))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(xdoc::evmac-topic-input-processing defsurj)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defsurj-process-name (name ctx state)
  :returns (mv erp (nothing null) state)
  :verify-guards nil
  :short "Process the @('name') input."
  (b* (((er &) (ensure-symbol$ name "The first input" t nil))
       ((er &) (ensure-symbol-not-keyword$ name "The first input" t nil)))
    (value nil)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defsurj-process-function
  ((function "The @('doma'), @('domb'), @('alpha'), or @('beta')
              input to @(tsee defsurj).")
   (position (member position '(2 3 4 5))
             "Position of the input in the ordered inputs to @(tsee defsurj).")
   (guard-thms$ booleanp)
   ctx
   state)
  :returns (mv erp
               (result "A tuple @('(function$
                                    arity
                                    numres)')
                        satisfying
                        @('(typed-tuplep pseudo-termfnp
                                         natp
                                         natp)').")
               state)
  :mode :program
  :short "Process one of the input functions
          (i.e. @('doma'), @('domb'), @('alpha'), or @('beta'))."
  :long
  (xdoc::topstring-p
   "Return either the input unchanges (if it is a function name)
    or its translation (if it is a lambda expression).
    Also return the arity and the number of results.")
  (b* (((er (list fn/lambda stobjs-in stobjs-out description))
        (ensure-function/macro/lambda$ function
                                       (msg "The ~n0 input" (list position))
                                       t nil))
       ((er &) (ensure-function/lambda-logic-mode$ fn/lambda description t nil))
       ((er &) (ensure-function/lambda-no-stobjs$ stobjs-in
                                                  stobjs-out
                                                  description t nil))
       ((er &) (ensure-function/lambda-closed$ fn/lambda description t nil))
       ((unless guard-thms$) (value (list fn/lambda
                                          (len stobjs-in)
                                          (len stobjs-out))))
       ((er &) (ensure-function/lambda-guard-verified-exec-fns$
                fn/lambda
                (msg
                 "Since the :GUARD-THMS input is (perhaps by default) T, ~@0"
                 (msg-downcase-first description))
                t nil)))
    (value (list fn/lambda
                 (len stobjs-in)
                 (len stobjs-out)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defsurj-process-functions (doma domb alpha beta guard-thms$ ctx state)
  :returns (mv erp
               (result "A tuple @('(doma$ domb$ alpha$ beta$)')
                        satisfying @('(typed-tuplep pseudo-termfnp
                                                    pseudo-termfnp
                                                    pseudo-termfnp
                                                    pseudo-termfnp
                                                    result)').")
               state)
  :mode :program
  :short "Process the @('doma'), @('domb'), @('alpha'), and @('beta') inputs."
  :long
  (xdoc::topstring-p
   "We call @(tsee defsurj-process-function) on each
    and then we check the constraints on the arities and numbers of results.")
  (b* (((er (list doma$ doma-arity doma-numres))
        (defsurj-process-function doma 2 guard-thms$ ctx state))
       ((er (list domb$ domb-arity domb-numres))
        (defsurj-process-function domb 3 guard-thms$ ctx state))
       ((er (list alpha$ alpha-arity alpha-numres))
        (defsurj-process-function alpha 4 guard-thms$ ctx state))
       ((er (list beta$ beta-arity beta-numres))
        (defsurj-process-function beta 5 guard-thms$ ctx state))
       ((unless (= doma-numres 1))
        (er-soft+ ctx t nil
                  "The number of results returned by the domain ~x0 ~
                   must be 1, but it is ~x1 instead."
                  doma doma-numres))
       ((unless (= domb-numres 1))
        (er-soft+ ctx t nil
                  "The number of results returned by the domain ~x0 ~
                   must be 1, but it is ~x1 instead."
                  domb domb-numres))
       ((unless (= alpha-arity doma-arity))
        (er-soft+ ctx t nil
                  "The arity of the isomorphism ~x0 ~
                   must equal the arity ~x1 of the domain ~x2, ~
                   but it is ~x3 instead."
                  alpha doma-arity doma alpha-arity))
       ((unless (= alpha-numres domb-arity))
        (er-soft+ ctx t nil
                  "The number of results of the isomorphism ~x0 ~
                   must equal the arity ~x1 of the domain ~x2, ~
                   but it is ~x3 instead."
                  alpha domb-arity domb alpha-numres))
       ((unless (= beta-arity domb-arity))
        (er-soft+ ctx t nil
                  "The arity of the isomorphism ~x0 ~
                   must equal the arity ~x1 of the domain ~x2, ~
                   but it is ~x3 instead."
                  beta domb-arity domb beta-arity))
       ((unless (= beta-numres doma-arity))
        (er-soft+ ctx t nil
                  "The number of results of the isomorphism ~x0 ~
                   must equal the arity ~x1 of the domain ~x2, ~
                   but it is ~x3 instead."
                  beta doma-arity doma beta-numres)))
    (value (list doma$ domb$ alpha$ beta$))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defval *defsurj-required-appcond-keywords*
  :short "Keywords that identify the required applicability conditions,
          i.e. the ones that are always present."
  (list :alpha-image
        :beta-image
        :alpha-of-beta))

(defval *defsurj-optional-appcond-keywords*
  :short "Keywords that identify the optional applicability conditions,
          i.e. the ones that may or may not be present."
  (list :doma-guard
        :domb-guard
        :alpha-guard
        :beta-guard))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defsurj-thm-keywords ((guard-thms$ booleanp))
  :returns (thm-keywords symbol-listp)
  :short "Keywords that identify all the theorems to generate."
  (if guard-thms$
      (append *defsurj-required-appcond-keywords*
              *defsurj-optional-appcond-keywords*)
    *defsurj-required-appcond-keywords*)
  ///

  (more-returns
   (thm-keywords no-duplicatesp-eq
                 :name no-duplicatesp-eq-of-defsurj-thm-keywords)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defsurj-process-thm-names (thm-names
                                   (name$ symbolp)
                                   (guard-thms$ booleanp)
                                   ctx
                                   state)
  :returns (mv erp
               (thm-names$ "A @(tsee symbol-symbol-alistp).")
               state)
  :verify-guards nil
  :short "Process the @(':thm-names') input."
  :long
  (xdoc::topstring
   (xdoc::p
    "We compute the names for all the theorems to generate,
     and we return them as a complete alist
     from the keywords that identify the theorems
     to the corresponding theorem names.
     The alist has unique keys.")
   (xdoc::p
    "If an explicit theorem name is supplied in the @(':thm-names') input,
     it is used;
     otherwise, the theorem name is generated as explained in the documentation.
     The theorem names, whether generated or supplied,
     must be valid fresh theorem names.
     They must also be all distinct;
     this is always the case if the theorem names are all generated,
     because the keywords used in their names are all distinct."))
  (b* (((er &) (ensure-keyword-value-list$ thm-names
                                           "The :THM-NAMES input" t nil))
       (thm-names-alist (keyword-value-list-to-alist thm-names))
       (keys (strip-cars thm-names-alist))
       (description
        (msg "The list ~x0 of keywords of the :THM-NAMES input" keys))
       ((er &) (ensure-list-no-duplicates$ keys description t nil))
       (thm-keywords (defsurj-thm-keywords guard-thms$))
       ((er &) (ensure-list-subset$ keys thm-keywords description t nil))
       ((er thm-names$) (defsurj-process-thm-names-aux
                          thm-keywords thm-names-alist name$ ctx state))
       (vals (strip-cdrs thm-names$))
       (description (msg "The list ~x0 of theorem names, ~
                          some of which may be supplied ~
                          in the :THM-NAMES input,"
                         vals))
       ((er &) (ensure-list-no-duplicates$ vals description t nil)))
    (value thm-names$))

  :prepwork
  ((define defsurj-process-thm-names-aux ((thm-keywords symbol-listp)
                                          (thm-names-alist symbol-alistp)
                                          (name$ symbolp)
                                          ctx
                                          state)
     :returns (mv erp
                  alist ; SYMBOL-SYMBOL-ALISTP
                  state)
     :verify-guards nil
     :parents nil ; override default
     (if (endp thm-keywords)
         (value nil)
       (b* ((thm-keyword (car thm-keywords))
            (pair (assoc-eq thm-keyword thm-names-alist))
            (thm-name (if pair
                          (cdr pair)
                        (add-suffix-to-fn name$
                                          (concatenate 'string
                                                       "."
                                                       (symbol-name
                                                        thm-keyword)))))
            (description (msg "The name ~x0 of the ~x1 theorem, ~@2,"
                              thm-name
                              thm-keyword
                              (if pair
                                  "supplied in the :THM-NAMES input"
                                "automatically generated")))
            ((er &) (ensure-symbol$ thm-name description t nil))
            ((er &) (ensure-symbol-new-event-name$ thm-name description t nil))
            ((er alist) (defsurj-process-thm-names-aux
                          (cdr thm-keywords) thm-names-alist name$ ctx state)))
         (value (acons thm-keyword thm-name alist)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defsurj-process-inputs (name
                                doma
                                domb
                                alpha
                                beta
                                guard-thms
                                thm-names
                                hints
                                print
                                show-only
                                ctx
                                state)
  :returns (mv erp
               (result "A tuple @('(doma$
                                    domb$
                                    alpha$
                                    beta$
                                    thm-names$
                                    hints$)')
                        satisfying
                        @('(typed-tuplep pseudo-termfnp
                                         pseudo-termfnp
                                         pseudo-termfnp
                                         pseudo-termfnp
                                         symbol-symbol-alistp
                                         symbol-truelist-alistp
                                         result)'),
                        where the first 4 components are
                        results of @(tsee defsurj-process-functions),
                        @('thm-names$') is
                        the result of @(tsee defsurj-process-thm-names), and
                        @('hints$') is
                        the result of @(tsee defsurj-process-hints).")
               state)
  :mode :program
  :short "Process all the inputs."
  (b* (((er &) (defsurj-process-name name ctx state))
       ((er &) (ensure-boolean$ guard-thms "The :GUARD-THMS input" t nil))
       ((er (list doma$ domb$ alpha$ beta$))
        (defsurj-process-functions doma domb alpha beta guard-thms ctx state))
       ((er thm-names$) (defsurj-process-thm-names
                          thm-names name guard-thms ctx state))
       ((er hints$) (evmac-process-input-hints hints ctx state))
       ((er &) (evmac-process-input-print print ctx state))
       ((er &) (evmac-process-input-show-only show-only ctx state)))
    (value (list doma$
                 domb$
                 alpha$
                 beta$
                 thm-names$
                 hints$))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(xdoc::evmac-topic-event-generation defsurj :some-local-nonlocal-p t)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defsurj-gen-var-a1...an ((alpha$ pseudo-termfnp)
                                 (wrld plist-worldp))
  :returns (a1...an "A @(tsee symbol-listp).")
  :verify-guards nil
  :short "Generate the list of variables @('(a1 ... an)')
          described in the documentation."
  :long
  (xdoc::topstring
   (xdoc::p
    "We use the formal parameters of the isomorphism @($\\alpha$)."))
  (cond ((symbolp alpha$) (formals alpha$ wrld))
        (t (lambda-formals alpha$))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defsurj-gen-var-b1...bm ((beta$ pseudo-termfnp)
                                 (wrld plist-worldp))
  :returns (b1...bm "A @(tsee symbol-listp).")
  :verify-guards nil
  :short "Generate the list of variables @('(b1 ... bm)')
          described in the documentation."
  :long
  (xdoc::topstring
   (xdoc::p
    "We use the formal parameters of the isomorphism @($\\beta$)."))
  (cond ((symbolp beta$) (formals beta$ wrld))
        (t (lambda-formals beta$))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defsurj-differentiate-a/b-vars ((a1/b1...an/bm symbol-listp)
                                        (b1/a1...bm/an symbol-listp))
  :returns (a1/b1...an/bm-differentiated "A @(tsee symbol-listp).")
  :mode :program
  :short "Ensure that the variables
          @('a1'), ..., @('an') or @('b1'), ..., @('bm')
          do not overlap with
          @('b1'), ..., @('bm') or @('a1'), ..., @('an')."
  :long
  (xdoc::topstring
   (xdoc::p
    "In the formula of the @(':alpha-of-beta') applicability condition,
     in certain cases @('a1'), ..., @('an') are bound by @(tsee mv-let),
     and @('b1'), ..., @('bm') are used in the body of the @(tsee mv-let):
     if any @('bj') were identical to any @('ai'),
     the formula would be incorrect in general.
     A similar situation occurs
     with the @(':beta-of-alpha') applicability condition,
     with the roles of @('a1'), ..., @('an') and @('b1'), ..., @('bm') swapped.
     Thus, in these cases we may need to differentiate
     @('a1'), ..., @('an') apart from @('b1'), ..., @('bm') or vice versa.
     We do that here, using @(tsee genvar)."))
  (cond ((endp a1/b1...an/bm) nil)
        (t (b* ((a2/b2...an/bm-differentiated
                 (defsurj-differentiate-a/b-vars
                   (cdr a1/b1...an/bm) b1/a1...bm/an))
                (a1/b1 (car a1/b1...an/bm))
                (a1/b1-differentiated
                 (genvar a1/b1
                         (symbol-name a1/b1)
                         nil
                         (append b1/a1...bm/an
                                 a2/b2...an/bm-differentiated))))
             (cons a1/b1-differentiated
                   a2/b2...an/bm-differentiated)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defsurj-gen-var-aa/bb ((a1/b1...an/bm symbol-listp))
  :returns (aa1/bb1...aan/bbm "A @(tsee symbol-listp).")
  :mode :program
  :short "Generate the list of variables
          @('(aa1 ... aan)') or @('(bb1 ... bbm)')
          described in the documentation."
  :long
  (xdoc::topstring-p
   "We generate these by appending @('$') to each of
    @('(a1 ... an)') or @('(b1 ... bm)'),
    using @(tsee genvar) to ensure that we do not introduce clashes.")
  (cond ((endp a1/b1...an/bm) nil)
        (t (b* ((aa2/bb2...aan/bbm (defsurj-gen-var-aa/bb
                                     (cdr a1/b1...an/bm)))
                (a1/b1 (car a1/b1...an/bm))
                (aa1/bb1 (genvar a1/b1
                                 (str::cat (symbol-name a1/b1) "$")
                                 nil
                                 (append a1/b1...an/bm aa2/bb2...aan/bbm))))
             (cons aa1/bb1 aa2/bb2...aan/bbm)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defsurj-gen-appconds ((doma$ pseudo-termfnp)
                              (domb$ pseudo-termfnp)
                              (alpha$ pseudo-termfnp)
                              (beta$ pseudo-termfnp)
                              (a1...an symbol-listp)
                              (b1...bm symbol-listp)
                              (guard-thms$ booleanp)
                              state)
  :returns (appconds "A @(tsee evmac-appcond-listp).")
  :mode :program
  :short "Generate the applicability conditions."
  (b* ((wrld (w state))
       (n (arity doma$ wrld))
       (m (arity domb$ wrld)))
    (append
     (make-evmac-appcond?
      :alpha-image
      (b* ((antecedent (apply-term doma$ a1...an))
           (consequent (if (= m 1)
                           (apply-term* domb$
                                        (apply-term alpha$ a1...an))
                         (make-mv-let-call 'mv
                                           b1...bm
                                           :all
                                           (apply-term alpha$ a1...an)
                                           (apply-term domb$ b1...bm)))))
        (implicate antecedent consequent)))
     (make-evmac-appcond?
      :beta-image
      (b* ((antecedent (apply-term domb$ b1...bm))
           (consequent (if (= n 1)
                           (apply-term* doma$
                                        (apply-term beta$ b1...bm))
                         (make-mv-let-call 'mv
                                           a1...an
                                           :all
                                           (apply-term beta$ b1...bm)
                                           (apply-term doma$ a1...an)))))
        (implicate antecedent consequent)))
     (make-evmac-appcond?
      :alpha-of-beta
      (b* ((antecedent (apply-term domb$ b1...bm))
           (consequent
            (if (= n 1)
                (if (= m 1)
                    (b* ((b (car b1...bm)))
                      `(equal ,(apply-term* alpha$
                                            (apply-term* beta$
                                                         b))
                              ,b))
                  (b* ((bb1...bbm (defsurj-gen-var-aa/bb b1...bm)))
                    (make-mv-let-call 'mv
                                      bb1...bbm
                                      :all
                                      (apply-term* alpha$
                                                   (apply-term beta$ b1...bm))
                                      (conjoin-equalities bb1...bbm b1...bm))))
              (if (= m 1)
                  (b* ((b (car b1...bm))
                       (a1...an (defsurj-differentiate-a/b-vars
                                  a1...an b1...bm)))
                    (make-mv-let-call 'mv
                                      a1...an
                                      :all
                                      (apply-term* beta$ b)
                                      `(equal ,(apply-term alpha$ a1...an)
                                              ,b)))
                (b* ((bb1...bbm (defsurj-gen-var-aa/bb b1...bm))
                     (a1...an (defsurj-differentiate-a/b-vars
                                a1...an b1...bm)))
                  (make-mv-let-call
                   'mv
                   a1...an
                   :all
                   (apply-term beta$ b1...bm)
                   (make-mv-let-call
                    'mv
                    bb1...bbm
                    :all
                    (apply-term alpha$ a1...an)
                    (conjoin-equalities bb1...bbm b1...bm))))))))
        (implicate antecedent consequent)))
     (make-evmac-appcond?
      :doma-guard
      (cond ((symbolp doma$) (uguard doma$ wrld))
            (t (term-guard-obligation (lambda-body doma$) state)))
      :when guard-thms$)
     (make-evmac-appcond?
      :domb-guard
      (cond ((symbolp domb$) (uguard domb$ wrld))
            (t (term-guard-obligation (lambda-body domb$) state)))
      :when guard-thms$)
     (make-evmac-appcond?
      :alpha-guard
      (b* ((alpha-formals
            (cond ((symbolp alpha$) (formals alpha$ wrld))
                  (t (lambda-formals alpha$))))
           (alpha-guard
            (cond ((symbolp alpha$) (uguard alpha$ wrld))
                  (t (term-guard-obligation (lambda-body alpha$) state)))))
        (implicate (apply-term doma$ a1...an)
                   (subcor-var alpha-formals
                               a1...an
                               alpha-guard)))
      :when guard-thms$)
     (make-evmac-appcond?
      :beta-guard
      (b* ((beta-formals
            (cond ((symbolp beta$) (formals beta$ wrld))
                  (t (lambda-formals beta$))))
           (beta-guard
            (cond ((symbolp beta$) (uguard beta$ wrld))
                  (t (term-guard-obligation (lambda-body beta$) state)))))
        (implicate (apply-term domb$ b1...bm)
                   (subcor-var beta-formals
                               b1...bm
                               beta-guard)))
      :when guard-thms$))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defsurj-gen-appcond-thm ((appcond evmac-appcondp)
                                 (appcond-thm-names symbol-symbol-alistp)
                                 (thm-names$ symbol-symbol-alistp)
                                 (wrld plist-worldp))
  :returns (mv (local-event "A @(tsee pseudo-event-formp).")
               (exported-event "A @(tsee pseudo-event-formp)."))
  :mode :program
  :short "Generate a theorem event from an applicability condition."
  :long
  (xdoc::topstring
   (xdoc::p
    "All the applicability conditions
     that must hold for the @(tsee defsurj) call
     are turned into theorems exported from the @(tsee encapsulate).
     To keep the ACL2 history ``clean'',
     we generate the theorem in local form with a @(':by') hint
     (the references the local theorem name of the applicability condition;
     this name generally differs from
     the theorem name determined by @(':thm-names')),
     and in non-local, redundant form without hints."))
  (b* (((evmac-appcond appcond) appcond)
       (thm-name (cdr (assoc-eq appcond.name thm-names$)))
       (thm-formula (untranslate appcond.formula t wrld))
       (thm-hints
        `(("Goal" :by ,(cdr (assoc-eq appcond.name appcond-thm-names)))))
       (local-event `(local (defthmr ,thm-name ,thm-formula :hints ,thm-hints)))
       (exported-event `(defthmr ,thm-name ,thm-formula)))
    (mv local-event exported-event)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defsurj-gen-appcond-thms ((appconds evmac-appcond-listp)
                                  (appcond-thm-names symbol-symbol-alistp)
                                  (thm-names$ symbol-symbol-alistp)
                                  (wrld plist-worldp))
  :returns (mv (local-events "A @(tsee pseudo-event-form-listp).")
               (exported-events "A @(tsee pseudo-event-form-listp)."))
  :mode :program
  :short "Lift @(tsee defsurj-gen-appcond-thm) to
          lists of applicability conditions."
  (b* (((when (endp appconds)) (mv nil nil))
       ((mv local-event exported-event) (defsurj-gen-appcond-thm
                                          (car appconds)
                                          appcond-thm-names
                                          thm-names$
                                          wrld))
       ((mv local-events exported-events) (defsurj-gen-appcond-thms
                                            (cdr appconds)
                                            appcond-thm-names
                                            thm-names$
                                            wrld)))
    (mv (cons local-event local-events)
        (cons exported-event exported-events))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defsurj-gen-ext-table ((name$ symbolp)
                               (doma$ pseudo-termfnp)
                               (domb$ pseudo-termfnp)
                               (alpha$ pseudo-termfnp)
                               (beta$ pseudo-termfnp)
                               (thm-names$ symbol-symbol-alistp)
                               (call$ pseudo-event-formp)
                               (expansion pseudo-event-formp))
  :returns (event pseudo-event-formp)
  :verify-guards nil
  :short "Generate the event that extends the @(tsee defsurj) table."
  (b* ((alpha-image (cdr (assoc-eq :alpha-image thm-names$)))
       (beta-image (cdr (assoc-eq :beta-image thm-names$)))
       (alpha-of-beta (cdr (assoc-eq :alpha-of-beta thm-names$)))
       (doma-guard (cdr (assoc-eq :doma-guard thm-names$)))
       (domb-guard (cdr (assoc-eq :domb-guard thm-names$)))
       (alpha-guard (cdr (assoc-eq :alpha-guard thm-names$)))
       (beta-guard (cdr (assoc-eq :beta-guard thm-names$)))
       (info (make-defsurj-info :call$ call$
                                :expansion expansion
                                :doma doma$
                                :domb domb$
                                :alpha alpha$
                                :beta beta$
                                :alpha-image alpha-image
                                :beta-image beta-image
                                :alpha-of-beta alpha-of-beta
                                :doma-guard doma-guard
                                :domb-guard domb-guard
                                :alpha-guard alpha-guard
                                :beta-guard beta-guard)))
    `(table ,*defsurj-table-name* ',name$ ',info)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defsurj-gen-print-result ((thms pseudo-event-form-listp))
  :returns (cw-events pseudo-event-form-listp)
  :short "Generate the events that print the result."
  :long
  (xdoc::topstring-p
   "This refers to the @(':result') value of the @(':print') input.
    The result to print consists of the generated theorems.
    These theorems are printed only if
    @(':print') is @(':result') or @(':info') or @(':all').")
  (if (endp thms)
      nil
    (cons `(cw-event "~x0~|" ',(car thms))
          (defsurj-gen-print-result (cdr thms)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defsurj-gen-everything ((name$ symbolp)
                                (doma$ pseudo-termfnp)
                                (domb$ pseudo-termfnp)
                                (alpha$ pseudo-termfnp)
                                (beta$ pseudo-termfnp)
                                (guard-thms$ booleanp)
                                (thm-names$ symbol-symbol-alistp)
                                (hints$ symbol-truelist-alistp)
                                (print$ evmac-input-print-p)
                                (show-only$ booleanp)
                                (call pseudo-event-formp)
                                ctx
                                state)
  :returns (mv erp (event "A @(tsee pseudo-event-formp).") state)
  :mode :program
  :verify-guards nil
  :short "Generate the top-level event."
  :long
  (xdoc::topstring
   (xdoc::p
    "This is a @(tsee progn) that consists of
     the expansion of @(tsee defsurj) (the @(tsee encapsulate)),
     followed by an event to extend the @(tsee defsurj) table,
     optionally followed by events to print the generated theorems.
     The @(tsee progn) ends with @(':invisible')
     to avoid printing a return value.")
   (xdoc::p
    "The expansion starts with an implicitly local event to
     ensure logic mode.")
   (xdoc::p
    "If @(':print') is @(':all'),
     the expansion is wrapped to show ACL2's output
     in response to the submitted events.
     If @(':print') is @(':info') or @(':all'),
     a blank line is printed just before the result, for visual separation;
     if @(':print') is @(':result'),
     the blank line is not printed.")
   (xdoc::p
    "If @(':show-only') is @('t'),
     the expansion is printed on the screen
     and not returned as part of the event to submit,
     which is in this case is just an @(':invisible') form.
     In this case, if @(':print') is @(':info') or @(':all'),
     a blank line is printed just before the @(tsee encapsulate),
     for visual separation."))
  (b* ((wrld (w state))
       (a1...an (defsurj-gen-var-a1...an alpha$ wrld))
       (b1...bm (defsurj-gen-var-b1...bm beta$ wrld))
       (appconds (defsurj-gen-appconds
                   doma$ domb$ alpha$ beta$ a1...an b1...bm guard-thms$ state))
       ((er (list appcond-events appcond-thm-names &))
        (evmac-appcond-theorems-no-extra-hints
         appconds hints$ nil print$ ctx state))
       ((mv local-thm-events exported-thm-events)
        (defsurj-gen-appcond-thms appconds appcond-thm-names thm-names$ wrld))
       (expansion `(encapsulate
                     ()
                     (logic)
                     (set-ignore-ok t)
                     ,@appcond-events
                     ,@local-thm-events
                     ,@exported-thm-events))
       ((when show-only$)
        (if (member-eq print$ '(:info :all))
            (cw "~%~x0~|" expansion)
          (cw "~x0~|" expansion))
        (value '(value-triple :invisible)))
       (expansion+ (restore-output? (eq print$ :all) expansion))
       (call$ (defsurj-filter-call call))
       (extend-table (defsurj-gen-ext-table
                       name$
                       doma$
                       domb$
                       alpha$
                       beta$
                       thm-names$
                       call$
                       expansion))
       (print-result (and (member-eq print$ '(:result :info :all))
                          (append
                           (and (member-eq print$ '(:info :all))
                                '((cw-event "~%")))
                           (defsurj-gen-print-result exported-thm-events)))))
    (value
     `(progn
        ,expansion+
        ,extend-table
        ,@print-result
        (value-triple :invisible)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defsurj-check-redundancy (name
                                  print
                                  show-only
                                  (call pseudo-event-formp)
                                  ctx
                                  state)
  :returns (mv erp
               (yes/no "A @(tsee booleanp).")
               state)
  :verify-guards nil
  :parents (defsurj-implementation)
  :short "Check if a call to @(tsee defsurj) is redundant."
  :long
  (xdoc::topstring
   (xdoc::p
    "If the @(tsee defsurj) table has no entry for @('name'),
     we return @('nil'): the call is not redundant.")
   (xdoc::p
    "If the table has an entry for @('name') but the call differs
     (after removing any @(':print') and @(':show-only')),
     an error occurs.")
   (xdoc::p
    "If the call is redundant,
     we know that all the inputs except possibly @(':print') and @(':show-only')
     are valid
     (because they are the same as the ones of the recorded successful call);
     we validate these two inputs, for better error checking.
     If @(':show-only') is @('t'),
     we print the recorded expansion of the call.
     Unless @(':print') is @('nil'),
     we print a message saying that the call is redundant."))
  (b* ((table (table-alist *defsurj-table-name* (w state)))
       (pair (assoc-equal name table))
       ((unless pair) (value nil))
       (info (cdr pair))
       (call$ (defsurj-filter-call call))
       ((unless (equal call$ (defsurj-info->call$ info)))
        (er-soft+ ctx t nil
                  "A different call to DEFSURJ with name ~x0 ~
                   has already been performed."
                  name))
       ((er &) (evmac-process-input-print print ctx state))
       ((er &) (evmac-process-input-show-only show-only ctx state))
       ((run-when show-only)
        (cw "~x0~|" (defsurj-info->expansion info)))
       ((run-when print)
        (cw "~%The call ~x0 is redundant.~%" call)))
    (value t)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defsurj-fn (name
                    doma
                    domb
                    alpha
                    beta
                    guard-thms
                    thm-names
                    hints
                    print
                    show-only
                    (call pseudo-event-formp)
                    ctx
                    state)
  :returns (mv erp
               (event "A @(tsee pseudo-event-formp).")
               state)
  :parents (defsurj-implementation)
  :mode :program
  :short "Check redundancy,
          process the inputs,
          and generate the event to submit."
  (b* (((er redundant?) (defsurj-check-redundancy
                          name print show-only call ctx state))
       ((when redundant?) (value '(value-triple :invisible)))
       ((er (list doma$
                  domb$
                  alpha$
                  beta$
                  thm-names$
                  hints$))
        (defsurj-process-inputs
          name
          doma
          domb
          alpha
          beta
          guard-thms
          thm-names
          hints
          print
          show-only
          ctx
          state)))
    (defsurj-gen-everything
      name
      doma$
      domb$
      alpha$
      beta$
      guard-thms
      thm-names$
      hints$
      print
      show-only
      call
      ctx
      state)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defsection defsurj-macro-definition
  :parents (defsurj-implementation)
  :short "Definition of the @(tsee defsurj) macro."
  :long
  (xdoc::topstring
   (xdoc::p
    "Submit the event form generated by @(tsee defsurj-fn).")
   (xdoc::@def "defsurj"))
  (defmacro defsurj (&whole
                     call
                     ;; mandatory inputs:
                     name
                     doma
                     domb
                     alpha
                     beta
                     ;; optional inputs:
                     &key
                     (guard-thms 't)
                     (thm-names 'nil)
                     (hints 'nil)
                     (print ':result)
                     (show-only 'nil))
    `(make-event-terse (defsurj-fn
                         ',name
                         ',doma
                         ',domb
                         ',alpha
                         ',beta
                         ',guard-thms
                         ',thm-names
                         ',hints
                         ',print
                         ',show-only
                         ',call
                         (cons 'defsurj ',name)
                         state)
                       :suppress-errors ,(not print))))
