; APT (Automated Program Transformations) Library
;
; Copyright (C) 2020 Kestrel Institute (http://www.kestrel.edu)
;
; License: A 3-clause BSD license. See the LICENSE file distributed with ACL2.
;
; Author: Alessandro Coglio (coglio@kestrel.edu)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package "ACL2")

(include-book "divconq-templates")

(include-book "kestrel/event-macros/proof-preparation" :dir :system)
(include-book "std/testing/must-succeed-star" :dir :system)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; This file contains generic proofs for
; the termination, guard, and refinement theorems generated by DIVCONQ.
; The proofs are generic because they are based on template functions.
; The DIVCONQ implementation generates proofs consistently with this file.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Generate generic outputs of the transformation,
; corresponding to the generic inputs generated by GEN-INPUTS,
; for different values of n and m and
; different positions npos and mpos within 1,...,n and 1,...m
; (both npos and mpos are 0-based);
; the instantiations are passed explicitly
; so their structure is more clear than if they were calculated.

; generate list of variables Z1, ..., Zm:
(defun gen-z1...zm (m)
  (cond ((zp m) nil)
        (t (append (gen-z1...zm (1- m)) (list (packn (list 'z m)))))))

(defmacro gen-outputs (n npos m mpos &key equal-fold-necc-inst fold-correct-inst)
  (let* ((x1...xn (gen-x1...xn n))
         (z1...zm (gen-z1...zm m))
         (a1...am (gen-a1...am m x1...xn))
         (x1... (take npos x1...xn))
         (...xn (nthcdr npos x1...xn))
         (z1... (take mpos z1...zm))
         (...zm (nthcdr mpos z1...zm))
         (a1... (take mpos a1...am))
         (...am (nthcdr mpos a1...am)))
    `(encapsulate ()
       (evmac-prepare-proofs)
       (gen-funvar :name ?g :arity ,(1+ m))
       (gen-funvar :name ?h :arity ,(+ 2 m))
       (gen-fold-ext
        :z1... ,z1...
        :...zm ,@(list ...zm)
        :hints (("Goal" :in-theory nil))
        :guard-hints (("Goal" :in-theory nil)))
       (gen-spec-atom-ext
        :x1... ,x1...
        :...xn ,@(list ...xn)
        :a1... ,a1...
        :...am ,@(list ...am)
        :guard-hints (("Goal" :in-theory nil)))
       (gen-spec-cons-ext
        :x1... ,x1...
        :...xn ,@(list ...xn)
        :a1... ,a1...
        :...am ,@(list ...am)
        :guard-hints (("Goal" :in-theory nil)))
       (gen-equal-fold-ext
        :z1... ,z1...
        :...zm ,@(list ...zm)
        :guard-hints (("Goal" :in-theory nil)))
       (gen-fold-correct
        :x1... ,x1...
        :...xn ,@(list ...xn)
        :a1... ,a1...
        :...am ,@(list ...am)
        :hints (("Goal"
                 :in-theory '(fold[?g][?h] atom)
                 :induct (fold[?g][?h] ,@z1... x ,@...zm))
                '(:use (spec-atom[?g]-necc
                        (:instance spec-cons[?h]-necc
                         (y (fold[?g][?h] ,@a1... (cdr x) ,@...am)))))))
       (gen-new
        :guard-hints (("Goal" :in-theory nil)))
       (gen-old-if-new
        :hints (("Goal"
                 :in-theory '(old new)
                 :use ((:instance equal[?f][fold[?g][?h]]-necc
                        ,@equal-fold-necc-inst)
                       (:instance fold-correct
                        ,@fold-correct-inst))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Proof templates for n = m = 0.

(must-succeed*
 (gen-inputs 0 0 0 0)
 (gen-outputs 0 0 0 0
              :equal-fold-necc-inst ((x (old-witness)))
              :fold-correct-inst ((x (old-witness)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Proof templates for n = m = 1.

; (invariant to mpos)

(must-succeed*
 (gen-inputs 1 0 1 0)
 (gen-outputs 1 0 1 0
              :equal-fold-necc-inst ((x (mv-nth 0 (old-witness)))
                                     (z1 (a1 (mv-nth 1 (old-witness)))))
              :fold-correct-inst ((x (mv-nth 0 (old-witness)))
                                  (x1 (mv-nth 1 (old-witness))))))

(must-succeed*
 (gen-inputs 1 1 1 0)
 (gen-outputs 1 1 1 0
              :equal-fold-necc-inst ((x (mv-nth 1 (old-witness)))
                                     (z1 (a1 (mv-nth 0 (old-witness)))))
              :fold-correct-inst ((x1 (mv-nth 0 (old-witness)))
                                  (x (mv-nth 1 (old-witness))))))

(must-succeed*
 (gen-inputs 1 0 1 1)
 (gen-outputs 1 0 1 1
              :equal-fold-necc-inst ((x (mv-nth 0 (old-witness)))
                                     (z1 (a1 (mv-nth 1 (old-witness)))))
              :fold-correct-inst ((x (mv-nth 0 (old-witness)))
                                  (x1 (mv-nth 1 (old-witness))))))

(must-succeed*
 (gen-inputs 1 1 1 1)
 (gen-outputs 1 1 1 1
              :equal-fold-necc-inst ((x (mv-nth 1 (old-witness)))
                                     (z1 (a1 (mv-nth 0 (old-witness)))))
              :fold-correct-inst ((x1 (mv-nth 0 (old-witness)))
                                  (x (mv-nth 1 (old-witness))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Proof templates for n = 1 and m = 1.

; (invariant to mpos)

(must-succeed*
 (gen-inputs 2 0 1 0)
 (gen-outputs 2 0 1 0
              :equal-fold-necc-inst ((x (mv-nth 0 (old-witness)))
                                     (z1 (a1 (mv-nth 1 (old-witness))
                                             (mv-nth 2 (old-witness)))))
              :fold-correct-inst ((x (mv-nth 0 (old-witness)))
                                  (x1 (mv-nth 1 (old-witness)))
                                  (x2 (mv-nth 2 (old-witness))))))

(must-succeed*
 (gen-inputs 2 1 1 0)
 (gen-outputs 2 1 1 0
              :equal-fold-necc-inst ((x (mv-nth 1 (old-witness)))
                                     (z1 (a1 (mv-nth 0 (old-witness))
                                             (mv-nth 2 (old-witness)))))
              :fold-correct-inst ((x1 (mv-nth 0 (old-witness)))
                                  (x (mv-nth 1 (old-witness)))
                                  (x2 (mv-nth 2 (old-witness))))))

(must-succeed*
 (gen-inputs 2 2 1 0)
 (gen-outputs 2 2 1 0
              :equal-fold-necc-inst ((x (mv-nth 2 (old-witness)))
                                     (z1 (a1 (mv-nth 0 (old-witness))
                                             (mv-nth 1 (old-witness)))))
              :fold-correct-inst ((x1 (mv-nth 0 (old-witness)))
                                  (x2 (mv-nth 1 (old-witness)))
                                  (x (mv-nth 2 (old-witness))))))

(must-succeed*
 (gen-inputs 2 0 1 1)
 (gen-outputs 2 0 1 1
              :equal-fold-necc-inst ((x (mv-nth 0 (old-witness)))
                                     (z1 (a1 (mv-nth 1 (old-witness))
                                             (mv-nth 2 (old-witness)))))
              :fold-correct-inst ((x (mv-nth 0 (old-witness)))
                                  (x1 (mv-nth 1 (old-witness)))
                                  (x2 (mv-nth 2 (old-witness))))))

(must-succeed*
 (gen-inputs 2 1 1 1)
 (gen-outputs 2 1 1 1
              :equal-fold-necc-inst ((x (mv-nth 1 (old-witness)))
                                     (z1 (a1 (mv-nth 0 (old-witness))
                                             (mv-nth 2 (old-witness)))))
              :fold-correct-inst ((x1 (mv-nth 0 (old-witness)))
                                  (x (mv-nth 1 (old-witness)))
                                  (x2 (mv-nth 2 (old-witness))))))

(must-succeed*
 (gen-inputs 2 2 1 1)
 (gen-outputs 2 2 1 1
              :equal-fold-necc-inst ((x (mv-nth 2 (old-witness)))
                                     (z1 (a1 (mv-nth 0 (old-witness))
                                             (mv-nth 1 (old-witness)))))
              :fold-correct-inst ((x1 (mv-nth 0 (old-witness)))
                                  (x2 (mv-nth 1 (old-witness)))
                                  (x (mv-nth 2 (old-witness))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Proof templates for n = 1 and m = 2.

; (invariant to mpos)

(must-succeed*
 (gen-inputs 1 0 2 0)
 (gen-outputs 1 0 2 0
              :equal-fold-necc-inst ((x (mv-nth 0 (old-witness)))
                                     (z1 (a1 (mv-nth 1 (old-witness))))
                                     (z2 (a2 (mv-nth 1 (old-witness)))))
              :fold-correct-inst ((x (mv-nth 0 (old-witness)))
                                  (x1 (mv-nth 1 (old-witness))))))

(must-succeed*
 (gen-inputs 1 1 2 0)
 (gen-outputs 1 1 2 0
              :equal-fold-necc-inst ((x (mv-nth 1 (old-witness)))
                                     (z1 (a1 (mv-nth 0 (old-witness))))
                                     (z2 (a2 (mv-nth 0 (old-witness)))))
              :fold-correct-inst ((x1 (mv-nth 0 (old-witness)))
                                  (x (mv-nth 1 (old-witness))))))

(must-succeed*
 (gen-inputs 1 0 2 1)
 (gen-outputs 1 0 2 1
              :equal-fold-necc-inst ((x (mv-nth 0 (old-witness)))
                                     (z1 (a1 (mv-nth 1 (old-witness))))
                                     (z2 (a2 (mv-nth 1 (old-witness)))))
              :fold-correct-inst ((x (mv-nth 0 (old-witness)))
                                  (x1 (mv-nth 1 (old-witness))))))

(must-succeed*
 (gen-inputs 1 1 2 1)
 (gen-outputs 1 1 2 1
              :equal-fold-necc-inst ((x (mv-nth 1 (old-witness)))
                                     (z1 (a1 (mv-nth 0 (old-witness))))
                                     (z2 (a2 (mv-nth 0 (old-witness)))))
              :fold-correct-inst ((x1 (mv-nth 0 (old-witness)))
                                  (x (mv-nth 1 (old-witness))))))

(must-succeed*
 (gen-inputs 1 0 2 2)
 (gen-outputs 1 0 2 2
              :equal-fold-necc-inst ((x (mv-nth 0 (old-witness)))
                                     (z1 (a1 (mv-nth 1 (old-witness))))
                                     (z2 (a2 (mv-nth 1 (old-witness)))))
              :fold-correct-inst ((x (mv-nth 0 (old-witness)))
                                  (x1 (mv-nth 1 (old-witness))))))

(must-succeed*
 (gen-inputs 1 1 2 2)
 (gen-outputs 1 1 2 2
              :equal-fold-necc-inst ((x (mv-nth 1 (old-witness)))
                                     (z1 (a1 (mv-nth 0 (old-witness))))
                                     (z2 (a2 (mv-nth 0 (old-witness)))))
              :fold-correct-inst ((x1 (mv-nth 0 (old-witness)))
                                  (x (mv-nth 1 (old-witness))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Proof templates for n = m = 2.

; (invariant to mpos)

(must-succeed*
 (gen-inputs 2 0 2 0)
 (gen-outputs 2 0 2 0
              :equal-fold-necc-inst ((x (mv-nth 0 (old-witness)))
                                     (z1 (a1 (mv-nth 1 (old-witness))
                                             (mv-nth 2 (old-witness))))
                                     (z2 (a2 (mv-nth 1 (old-witness))
                                             (mv-nth 2 (old-witness)))))
              :fold-correct-inst ((x (mv-nth 0 (old-witness)))
                                  (x1 (mv-nth 1 (old-witness)))
                                  (x2 (mv-nth 2 (old-witness))))))

(must-succeed*
 (gen-inputs 2 1 2 0)
 (gen-outputs 2 1 2 0
              :equal-fold-necc-inst ((x (mv-nth 1 (old-witness)))
                                     (z1 (a1 (mv-nth 0 (old-witness))
                                             (mv-nth 2 (old-witness))))
                                     (z2 (a2 (mv-nth 0 (old-witness))
                                             (mv-nth 2 (old-witness)))))
              :fold-correct-inst ((x1 (mv-nth 0 (old-witness)))
                                  (x (mv-nth 1 (old-witness)))
                                  (x2 (mv-nth 2 (old-witness))))))

(must-succeed*
 (gen-inputs 2 2 2 0)
 (gen-outputs 2 2 2 0
              :equal-fold-necc-inst ((x (mv-nth 2 (old-witness)))
                                     (z1 (a1 (mv-nth 0 (old-witness))
                                             (mv-nth 1 (old-witness))))
                                     (z2 (a2 (mv-nth 0 (old-witness))
                                             (mv-nth 1 (old-witness)))))
              :fold-correct-inst ((x1 (mv-nth 0 (old-witness)))
                                  (x2 (mv-nth 1 (old-witness)))
                                  (x (mv-nth 2 (old-witness))))))

(must-succeed*
 (gen-inputs 2 0 2 1)
 (gen-outputs 2 0 2 1
              :equal-fold-necc-inst ((x (mv-nth 0 (old-witness)))
                                     (z1 (a1 (mv-nth 1 (old-witness))
                                             (mv-nth 2 (old-witness))))
                                     (z2 (a2 (mv-nth 1 (old-witness))
                                             (mv-nth 2 (old-witness)))))
              :fold-correct-inst ((x (mv-nth 0 (old-witness)))
                                  (x1 (mv-nth 1 (old-witness)))
                                  (x2 (mv-nth 2 (old-witness))))))

(must-succeed*
 (gen-inputs 2 1 2 1)
 (gen-outputs 2 1 2 1
              :equal-fold-necc-inst ((x (mv-nth 1 (old-witness)))
                                     (z1 (a1 (mv-nth 0 (old-witness))
                                             (mv-nth 2 (old-witness))))
                                     (z2 (a2 (mv-nth 0 (old-witness))
                                             (mv-nth 2 (old-witness)))))
              :fold-correct-inst ((x1 (mv-nth 0 (old-witness)))
                                  (x (mv-nth 1 (old-witness)))
                                  (x2 (mv-nth 2 (old-witness))))))

(must-succeed*
 (gen-inputs 2 2 2 1)
 (gen-outputs 2 2 2 1
              :equal-fold-necc-inst ((x (mv-nth 2 (old-witness)))
                                     (z1 (a1 (mv-nth 0 (old-witness))
                                             (mv-nth 1 (old-witness))))
                                     (z2 (a2 (mv-nth 0 (old-witness))
                                             (mv-nth 1 (old-witness)))))
              :fold-correct-inst ((x1 (mv-nth 0 (old-witness)))
                                  (x2 (mv-nth 1 (old-witness)))
                                  (x (mv-nth 2 (old-witness))))))

(must-succeed*
 (gen-inputs 2 0 2 2)
 (gen-outputs 2 0 2 2
              :equal-fold-necc-inst ((x (mv-nth 0 (old-witness)))
                                     (z1 (a1 (mv-nth 1 (old-witness))
                                             (mv-nth 2 (old-witness))))
                                     (z2 (a2 (mv-nth 1 (old-witness))
                                             (mv-nth 2 (old-witness)))))
              :fold-correct-inst ((x (mv-nth 0 (old-witness)))
                                  (x1 (mv-nth 1 (old-witness)))
                                  (x2 (mv-nth 2 (old-witness))))))

(must-succeed*
 (gen-inputs 2 1 2 2)
 (gen-outputs 2 1 2 2
              :equal-fold-necc-inst ((x (mv-nth 1 (old-witness)))
                                     (z1 (a1 (mv-nth 0 (old-witness))
                                             (mv-nth 2 (old-witness))))
                                     (z2 (a2 (mv-nth 0 (old-witness))
                                             (mv-nth 2 (old-witness)))))
              :fold-correct-inst ((x1 (mv-nth 0 (old-witness)))
                                  (x (mv-nth 1 (old-witness)))
                                  (x2 (mv-nth 2 (old-witness))))))

(must-succeed*
 (gen-inputs 2 2 2 2)
 (gen-outputs 2 2 2 2
              :equal-fold-necc-inst ((x (mv-nth 2 (old-witness)))
                                     (z1 (a1 (mv-nth 0 (old-witness))
                                             (mv-nth 1 (old-witness))))
                                     (z2 (a2 (mv-nth 0 (old-witness))
                                             (mv-nth 1 (old-witness)))))
              :fold-correct-inst ((x1 (mv-nth 0 (old-witness)))
                                  (x2 (mv-nth 1 (old-witness)))
                                  (x (mv-nth 2 (old-witness))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Generate functions with termination and guard proofs,
; and theorems with proofs.

(defmacro gen-fold-with-proofs (&key vars1 vars2)
  `(gen-fold :name fold[?g][?h]
             :?g ?g
             :?h ?h
             :vars1 ,vars1
             :var list
             :vars2 ,vars2
             :hints (("Goal" :in-theory nil))
             :guard-hints (("Goal" :in-theory nil))))

(defmacro gen-spec-atom-with-proofs (&key vars1 vars2)
  `(gen-spec-atom :name spec-atom[?g]
                  :?g ?g
                  :vars1 ,vars1
                  :var list
                  :vars2 ,vars2
                  :iorel iorel
                  :guard-hints (("Goal" :in-theory nil))))

(defmacro gen-spec-cons-with-proofs (&key vars1 vars2)
  `(gen-spec-cons :name spec-cons[?h]
                  :?h ?h
                  :vars1 ,vars1
                  :var list
                  :vars2 ,vars2
                  :cdrout cdrout
                  :iorel iorel
                  :guard-hints (("Goal" :in-theory nil))))

(defmacro gen-equal-fold-with-proofs (&key vars1 vars2)
  `(gen-equal-fold :name equal[?f][fold[?g][?h]]
                   :?f ?f
                   :fold fold[?g][?h]
                   :vars (,@vars1 list ,@vars2)
                   :guard-hints (("Goal" :in-theory nil))))

(defmacro gen-new-with-proofs ()
  `(gen-new :name new
            :equal-fold equal[?f][fold[?g][?h]]
            :spec-atom spec-atom[?g]
            :spec-cons spec-cons[?h]
            :guard-hints (("Goal" :in-theory nil))))

(defmacro gen-fold-correct-with-proofs (&key vars1 vars2)
  `(defthm fold-correct
     (implies (and (spec-atom[?g])
                   (spec-cons[?h]))
              (iorel ,@vars1 list ,@vars2 (fold[?g][?h] ,@vars1 list ,@vars2)))
     :rule-classes nil
     :hints (("Goal"
              :in-theory '(len fold[?g][?h] atom)
              :induct (len list))
             '(:use (spec-atom[?g]-necc
                     (:instance spec-cons[?h]-necc
                      (cdrout (fold[?g][?h] ,@vars1 (cdr list) ,@vars2))))))))

(defun gen-instantiation-1-0 ()
  '((list (old-witness))))

(defun gen-instantiation-2-0 (x)
  `((list (mv-nth 0 (old-witness)))
    (,x (mv-nth 1 (old-witness)))))

(defun gen-instantiation-2-1 (x)
  `((,x (mv-nth 0 (old-witness)))
    (list (mv-nth 1 (old-witness)))))

(defun gen-instantiation-3-0 (x y)
  `((list (mv-nth 0 (old-witness)))
    (,x (mv-nth 1 (old-witness)))
    (,y (mv-nth 2 (old-witness)))))

(defun gen-instantiation-3-1 (x y)
  `((,x (mv-nth 0 (old-witness)))
    (list (mv-nth 1 (old-witness)))
    (,y (mv-nth 2 (old-witness)))))

(defun gen-instantiation-3-2 (x y)
  `((,x (mv-nth 0 (old-witness)))
    (,y (mv-nth 1 (old-witness)))
    (list (mv-nth 2 (old-witness)))))

(defun gen-instantiation-4-0 (x y z)
  `((list (mv-nth 0 (old-witness)))
    (,x (mv-nth 1 (old-witness)))
    (,y (mv-nth 2 (old-witness)))
    (,z (mv-nth 3 (old-witness)))))

(defun gen-instantiation-4-1 (x y z)
  `((,x (mv-nth 0 (old-witness)))
    (list (mv-nth 1 (old-witness)))
    (,y (mv-nth 2 (old-witness)))
    (,z (mv-nth 3 (old-witness)))))

(defun gen-instantiation-4-2 (x y z)
  `((,x (mv-nth 0 (old-witness)))
    (,y (mv-nth 1 (old-witness)))
    (list (mv-nth 2 (old-witness)))
    (,z (mv-nth 3 (old-witness)))))

(defun gen-instantiation-4-3 (x y z)
  `((,x (mv-nth 0 (old-witness)))
    (,y (mv-nth 1 (old-witness)))
    (,z (mv-nth 2 (old-witness)))
    (list (mv-nth 3 (old-witness)))))

(defmacro gen-old-if-new-with-proofs (instantiation)
  (let ((lemma-instances
         `((:instance equal[?f][fold[?g][?h]]-necc ,@instantiation)
           (:instance fold-correct ,@instantiation))))
    `(gen-old-if-new :name old-if-new
                     :old old
                     :new new
                     :hints (("Goal"
                              :in-theory '(new old)
                              :use ,lemma-instances)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Generate all the above functions and theorems with proofs.

(defun gen-all-with-proofs-fn (vars1 vars2 instantiation)
  `(progn
     (evmac-prepare-proofs)
     (gen-funvar :name ?g :arity ,(+ 1 (len vars1) (len vars2)))
     (gen-funvar :name ?h :arity ,(+ 2 (len vars1) (len vars2)))
     (gen-fold-with-proofs :vars1 ,vars1 :vars2 ,vars2)
     (gen-spec-atom-with-proofs :vars1 ,vars1 :vars2 ,vars2)
     (gen-spec-cons-with-proofs :vars1 ,vars1 :vars2 ,vars2)
     (gen-equal-fold-with-proofs :vars1 ,vars1 :vars2 ,vars2)
     (gen-new-with-proofs)
     (gen-fold-correct-with-proofs :vars1 ,vars1 :vars2 ,vars2)
     (gen-old-if-new-with-proofs ,instantiation)))

(defmacro gen-all-with-proofs (&key vars1 vars2 instantiation)
  `(make-event (gen-all-with-proofs-fn ',vars1 ',vars2 ,instantiation)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Proof templates for n = 1.

(must-succeed*
 (gen-inputs-1-0)
 (gen-all-with-proofs :vars1 nil :vars2 nil
                      :instantiation (gen-instantiation-1-0)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Proof templates for n = 2.

(must-succeed*
 (gen-inputs-2-0)
 (gen-all-with-proofs :vars1 nil :vars2 (x)
                      :instantiation (gen-instantiation-2-0 'x)))

(must-succeed*
 (gen-inputs-2-1)
 (gen-all-with-proofs :vars1 (x) :vars2 nil
                      :instantiation (gen-instantiation-2-1 'x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Proof template for n = 3.

(must-succeed*
 (gen-inputs-3-0)
 (gen-all-with-proofs :vars1 nil :vars2 (x y)
                      :instantiation (gen-instantiation-3-0 'x 'y)))

(must-succeed*
 (gen-inputs-3-1)
 (gen-all-with-proofs :vars1 (x) :vars2 (y)
                      :instantiation (gen-instantiation-3-1 'x 'y)))

(must-succeed*
 (gen-inputs-3-2)
 (gen-all-with-proofs :vars1 (x y) :vars2 nil
                      :instantiation (gen-instantiation-3-2 'x 'y)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Proof template for n = 4.

(must-succeed*
 (gen-inputs-4-0)
 (gen-all-with-proofs :vars1 nil :vars2 (x y z)
                      :instantiation (gen-instantiation-4-0 'x 'y 'z)))

(must-succeed*
 (gen-inputs-4-1)
 (gen-all-with-proofs :vars1 (x) :vars2 (y z)
                      :instantiation (gen-instantiation-4-1 'x 'y 'z)))

(must-succeed*
 (gen-inputs-4-2)
 (gen-all-with-proofs :vars1 (x y) :vars2 (z)
                      :instantiation (gen-instantiation-4-2 'x 'y 'z)))

(must-succeed*
 (gen-inputs-4-3)
 (gen-all-with-proofs :vars1 (x y z) :vars2 nil
                      :instantiation (gen-instantiation-4-3 'x 'y 'z)))
