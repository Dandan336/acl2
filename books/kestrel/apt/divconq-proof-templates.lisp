; APT (Automated Program Transformations) Library
;
; Copyright (C) 2020 Kestrel Institute (http://www.kestrel.edu)
;
; License: A 3-clause BSD license. See the LICENSE file distributed with ACL2.
;
; Author: Alessandro Coglio (coglio@kestrel.edu)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package "ACL2")

(include-book "divconq-templates")

(include-book "kestrel/event-macros/proof-preparation" :dir :system)
(include-book "std/testing/must-succeed-star" :dir :system)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; This file contains generic proofs for
; the termination, guard, and refinement theorems generated by DIVCONQ.
; The proofs are generic because they are based on the templates
; defined in divconq-templates.lisp.
; The DIVCONQ implementation generates proofs
; according to the templates in this file.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Generate funtions with termination and guard proofs,
; and theorems with proofs.

(defmacro gen-fold-with-proofs (&key vars1 vars2)
  `(gen-fold :name fold[?g][?h]
             :?g ?g
             :?h ?h
             :vars1 ,vars1
             :var list
             :vars2 ,vars2
             :hints (("Goal" :in-theory nil))
             :guard-hints (("Goal" :in-theory nil))))

(defmacro gen-spec-atom-with-proofs (&key vars1 vars2)
  `(gen-spec-atom :name spec-atom[?g]
                  :?g ?g
                  :vars1 ,vars1
                  :var list
                  :vars2 ,vars2
                  :iorel iorel
                  :guard-hints (("Goal" :in-theory nil))))

(defmacro gen-spec-cons-with-proofs (&key vars1 vars2)
  `(gen-spec-cons :name spec-cons[?h]
                  :?h ?h
                  :vars1 ,vars1
                  :var list
                  :vars2 ,vars2
                  :cdrout cdrout
                  :iorel iorel
                  :guard-hints (("Goal" :in-theory nil))))

(defmacro gen-equal-fold-with-proofs (&key vars1 vars2)
  `(gen-equal-fold :name equal[?f][fold[?g][?h]]
                   :?f ?f
                   :fold fold[?g][?h]
                   :vars (,@vars1 list ,@vars2)
                   :guard-hints (("Goal" :in-theory nil))))

(defmacro gen-new-with-proofs ()
  `(gen-new :name new
            :equal-fold equal[?f][fold[?g][?h]]
            :spec-atom spec-atom[?g]
            :spec-cons spec-cons[?h]
            :guard-hints (("Goal" :in-theory nil))))

(defmacro gen-fold-correct-with-proofs (&key vars1 vars2)
  `(defthm fold-correct
     (implies (and (spec-atom[?g])
                   (spec-cons[?h]))
              (iorel ,@vars1 list ,@vars2 (fold[?g][?h] ,@vars1 list ,@vars2)))
     :rule-classes nil
     :hints (("Goal"
              :in-theory '(len fold[?g][?h] atom)
              :induct (len list))
             '(:use (spec-atom[?g]-necc
                     (:instance spec-cons[?h]-necc
                      (cdrout (fold[?g][?h] ,@vars1 (cdr list) ,@vars2))))))))

(defun gen-instantiation-1-0 ()
  '((list (old-witness))))

(defun gen-instantiation-2-0 (x)
  `((list (mv-nth 0 (old-witness)))
    (,x (mv-nth 1 (old-witness)))))

(defun gen-instantiation-2-1 (x)
  `((,x (mv-nth 0 (old-witness)))
    (list (mv-nth 1 (old-witness)))))

(defun gen-instantiation-3-0 (x y)
  `((list (mv-nth 0 (old-witness)))
    (,x (mv-nth 1 (old-witness)))
    (,y (mv-nth 2 (old-witness)))))

(defun gen-instantiation-3-1 (x y)
  `((,x (mv-nth 0 (old-witness)))
    (list (mv-nth 1 (old-witness)))
    (,y (mv-nth 2 (old-witness)))))

(defun gen-instantiation-3-2 (x y)
  `((,x (mv-nth 0 (old-witness)))
    (,y (mv-nth 1 (old-witness)))
    (list (mv-nth 2 (old-witness)))))

(defun gen-instantiation-4-0 (x y z)
  `((list (mv-nth 0 (old-witness)))
    (,x (mv-nth 1 (old-witness)))
    (,y (mv-nth 2 (old-witness)))
    (,z (mv-nth 3 (old-witness)))))

(defun gen-instantiation-4-1 (x y z)
  `((,x (mv-nth 0 (old-witness)))
    (list (mv-nth 1 (old-witness)))
    (,y (mv-nth 2 (old-witness)))
    (,z (mv-nth 3 (old-witness)))))

(defun gen-instantiation-4-2 (x y z)
  `((,x (mv-nth 0 (old-witness)))
    (,y (mv-nth 1 (old-witness)))
    (list (mv-nth 2 (old-witness)))
    (,z (mv-nth 3 (old-witness)))))

(defun gen-instantiation-4-3 (x y z)
  `((,x (mv-nth 0 (old-witness)))
    (,y (mv-nth 1 (old-witness)))
    (,z (mv-nth 2 (old-witness)))
    (list (mv-nth 3 (old-witness)))))

(defmacro gen-old-if-new-with-proofs (instantiation)
  (let ((lemma-instances
         `((:instance equal[?f][fold[?g][?h]]-necc ,@instantiation)
           (:instance fold-correct ,@instantiation))))
    `(gen-old-if-new :name old-if-new
                     :old old
                     :new new
                     :hints (("Goal"
                              :in-theory '(new old)
                              :use ,lemma-instances)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Generate all the above functions and theorems with proofs.

(defun gen-all-with-proofs-fn (vars1 vars2 instantiation)
  `(progn
     (evmac-prepare-proofs)
     (gen-funvar :name ?g :arity ,(+ 1 (len vars1) (len vars2)))
     (gen-funvar :name ?h :arity ,(+ 2 (len vars1) (len vars2)))
     (gen-fold-with-proofs :vars1 ,vars1 :vars2 ,vars2)
     (gen-spec-atom-with-proofs :vars1 ,vars1 :vars2 ,vars2)
     (gen-spec-cons-with-proofs :vars1 ,vars1 :vars2 ,vars2)
     (gen-equal-fold-with-proofs :vars1 ,vars1 :vars2 ,vars2)
     (gen-new-with-proofs)
     (gen-fold-correct-with-proofs :vars1 ,vars1 :vars2 ,vars2)
     (gen-old-if-new-with-proofs ,instantiation)))

(defmacro gen-all-with-proofs (&key vars1 vars2 instantiation)
  `(make-event (gen-all-with-proofs-fn ',vars1 ',vars2 ,instantiation)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Proof templates for n = 1.

(must-succeed*
 (gen-inputs-1-0)
 (gen-all-with-proofs :vars1 nil :vars2 nil
                      :instantiation (gen-instantiation-1-0)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Proof templates for n = 2.

(must-succeed*
 (gen-inputs-2-0)
 (gen-all-with-proofs :vars1 nil :vars2 (x)
                      :instantiation (gen-instantiation-2-0 'x)))

(must-succeed*
 (gen-inputs-2-1)
 (gen-all-with-proofs :vars1 (x) :vars2 nil
                      :instantiation (gen-instantiation-2-1 'x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Proof template for n = 3.

(must-succeed*
 (gen-inputs-3-0)
 (gen-all-with-proofs :vars1 nil :vars2 (x y)
                      :instantiation (gen-instantiation-3-0 'x 'y)))

(must-succeed*
 (gen-inputs-3-1)
 (gen-all-with-proofs :vars1 (x) :vars2 (y)
                      :instantiation (gen-instantiation-3-1 'x 'y)))

(must-succeed*
 (gen-inputs-3-2)
 (gen-all-with-proofs :vars1 (x y) :vars2 nil
                      :instantiation (gen-instantiation-3-2 'x 'y)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Proof template for n = 4.

(must-succeed*
 (gen-inputs-4-0)
 (gen-all-with-proofs :vars1 nil :vars2 (x y z)
                      :instantiation (gen-instantiation-4-0 'x 'y 'z)))

(must-succeed*
 (gen-inputs-4-1)
 (gen-all-with-proofs :vars1 (x) :vars2 (y z)
                      :instantiation (gen-instantiation-4-1 'x 'y 'z)))

(must-succeed*
 (gen-inputs-4-2)
 (gen-all-with-proofs :vars1 (x y) :vars2 (z)
                      :instantiation (gen-instantiation-4-2 'x 'y 'z)))

(must-succeed*
 (gen-inputs-4-3)
 (gen-all-with-proofs :vars1 (x y z) :vars2 nil
                      :instantiation (gen-instantiation-4-3 'x 'y 'z)))
