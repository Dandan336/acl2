; SOFT (Second-Order Functions and Theorems) Library
;
; Copyright (C) 2020 Kestrel Institute (http://www.kestrel.edu)
;
; License: A 3-clause BSD license. See the LICENSE file distributed with ACL2.
;
; Author: Alessandro Coglio (coglio@kestrel.edu)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package "SOFT")

(include-book "defunvar")

(include-book "kestrel/event-macros/cw-event" :dir :system)
(include-book "kestrel/event-macros/make-event-terse" :dir :system)
(include-book "kestrel/std/system/fundef-enabledp" :dir :system)
(include-book "kestrel/std/system/guard-verified-p" :dir :system)
(include-book "kestrel/std/system/irecursivep" :dir :system)
(include-book "kestrel/std/system/maybe-pseudo-event-formp" :dir :system)
(include-book "kestrel/std/system/well-founded-relation" :dir :system)
(include-book "kestrel/std/system/well-founded-relation-plus" :dir :system)
(include-book "kestrel/utilities/keyword-value-lists" :dir :system)
(include-book "kestrel/utilities/messages" :dir :system)
(include-book "xdoc/defxdoc-plus" :dir :system)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defxdoc+ soft-implementation
  :parents (soft)
  :short "Implementation of SOFT."
  :order-subtopics t
  :default-parent t)

(define ensure-wfrel-o< ((fn symbolp) ctx state)
  :returns (mv erp (nothing null) state)
  :short "Ensure that a function, if logic-mode and recursive,
          has @(tsee o<) as well-founded relation."
  :long
  (xdoc::topstring-p
   "For now, we only support logic-mode recursive second-order functions
    with the default well-founded relation (i.e. @(tsee o<)).
    This might be relaxed in the future.")
  (b* ((wrld (w state))
       ((unless (logicp fn wrld)) (value nil))
       ((unless (irecursivep fn wrld)) (value nil))
       (wfrel (well-founded-relation+ fn wrld))
       ((when (eq wfrel 'o<)) (value nil)))
    (er-soft+ ctx t nil
              "The well-founded relation of the recursive function ~x0 ~
               must be O<, but it is ~x1 instead."
              fn wfrel)))

(define ensure-defun-sk-rule-same-funvars ((fn symbolp) ctx state)
  :returns (mv erp (nothing "Always @('nil').") state)
  :mode :program
  :short "Ensure that a function, if introduced by @(tsee defun-sk),
          has an associated rewrite rule (the one generated by @(tsee defun-sk)
          that depends on exactly the same function variables
          that the function's matrix depends on."
  :long
  (xdoc::topstring-p
   "We collect
    the function variables that the @(tsee defun-sk) matrix depends on
    and the ones that the @(tsee defun-sk) rewrite rule depends on;
    we ensure that they are the same function variables.
    It seems unlikely that this check will ever fail in practice,
    but @(tsee defun-sk) allows custom rules (for universal quantifiers)
    that might somehow change the dependencies on function variables;
    for now we do not support this situation,
    but we might recosider this if some compelling example comes up.
    Unless the rewrite rule is a custom one,
    this check is always expected to pass.")
  (b* ((wrld (w state))
       ((unless (defun-sk-p fn wrld)) (value nil))
       (rule-name (defun-sk-rewrite-name fn wrld))
       (rule-body (formula rule-name nil wrld))
       (fn-matrix (defun-sk-matrix fn wrld))
       (rule-funvars (funvars-of-term rule-body wrld))
       (matrix-funvars (funvars-of-term fn-matrix wrld))
       ((when (set-equiv rule-funvars matrix-funvars)) (value nil))
       ((unless (eq (defun-sk-rewrite-kind fn wrld) :custom))
        (value (raise "Internal error: ~
                       the DEFUN-SK function ~x0 has a matrix ~x1
                       that depends on the function variables ~&2 ~
                       but a non-custom rewrite rule ~x3
                       that depends on the function variables ~&4.
                       This was not expected to happen."
                      fn fn-matrix matrix-funvars rule-body rule-funvars))))
    (er-soft+ ctx t nil
              "The DEFUN-SK function ~x0 has a matrix ~x1
               that depends on the function variables ~&2 ~
               but a custom rewrite rule ~x3
               that depends on the function variables ~&4."
              fn fn-matrix matrix-funvars rule-body rule-funvars)))

(define defsoft-fn (fn ctx state)
  :returns (mv erp event state)
  :mode :program
  :short "Generate the event submitted by @(tsee defsoft)."
  :long
  (xdoc::topstring
   (xdoc::p
    "The @(tsee defsoft) macro records an ACL2 function
     as a (SOFT) second-order function.
     This macro will become the primary one
     to introduce second-order functions,
     and @(tsee defun2), @(tsee defchoose2), and @(tsee defun-sk2)
     will be redefined as @(tsee defun), @(tsee defchoose), and @(tsee defun-sk)
     followed by @(tsee defsoft).")
   (xdoc::p
    "The input @('fn') must be a symbol that denotes an existing function
     that is introduced by @(tsee defchoose),
     or otherwise is introduced by @(tsee defun-sk),
     or otherwise has an unnormalized body
     (which implies that is is introduced by @(tsee defun)).
     Note that @(tsee defun-sk) functions
     are internally introduced by @(tsee defun),
     so it is important to check for @(tsee defun-sk) first.
     Functions introduced by @(tsee defun) but without an unnormalized body
     (such as the built-in program-mode functions)
     are disallowed because we cannot calculate
     the function variables that such functions depend on.
     For the same reason,
     constrained functions introduced by @(tsee encapsulate) are disallowed.")
   (xdoc::p
    "We collect the function variables that the function depends on,
     directly or indirecty; there must be at least one.
     If the function is introduced by @(tsee defun-sk),
     we also ensure that the associated rewrite rule
     does not depend on additional function variables.
     If the function is recursive,
     we also ensure that the well-founded relation is @(tsee o<)."))
  (b* ((wrld (w state))
       ((unless (symbolp fn))
        (er-soft+ ctx t nil
                  "The input must be a symbol, but it is ~x0 instead."
                  fn))
       ((unless (function-symbolp fn wrld))
        (er-soft+ ctx t nil
                  "The symbol ~x0 must be a function symbol, ~
                   but it is not."
                  fn))
       ((unless (or (defchoosep fn wrld)
                    (defun-sk-p fn wrld)
                    (ubody fn wrld)))
        (er-soft+ ctx t nil
                  "The function ~x0 must ~
                   be introduced by DEFCHOOSE, ~
                   be introduced by DEFUN-SK, ~
                   or have a non-NIL unnormalized body."
                  fn))
       (funvars (cond ((defchoosep fn wrld) (funvars-of-choice-fn fn wrld))
                      ((defun-sk-p fn wrld) (funvars-of-quantifier-fn fn wrld))
                      (t (funvars-of-plain-fn fn wrld))))
       (funvars (remove-duplicates-eq funvars))
       ((unless (consp funvars))
        (er-soft+ ctx t nil
                  "The function ~x0 is not second-order:
                   it depends on no function variables, directly or indirectly."
                  fn))
       (table-event `(table second-order-functions ',fn ',funvars))
       (print-event `(cw-event "The second-order function ~x0 ~
                                depends on the function variables ~x1.~%"
                               ',fn ',funvars))
       ((er &) (ensure-wfrel-o< fn ctx state))
       ((er &) (ensure-defun-sk-rule-same-funvars fn ctx state)))
    (value
     `(progn
        ,table-event
        ,print-event
        (value-triple ',fn)))))

(defmacro+ defsoft (fn)
  :short "Record a function as a second-order function."
  `(make-event-terse (defsoft-fn ',fn (cons 'defsoft ',fn) state)))

(defmacro acl2::defsoft (&rest args)
  `(defsoft ,@args))

(define check-qrewrite-rule-funvars ((fun symbolp) (wrld plist-worldp))
  :returns (err-msg? "A @(tsee maybe-msgp).")
  :mode :program
  :short "Check if the rewrite rule of a quantifier second-order function,
          or of an instance of it,
          depends exactly on the same function variables
          that the matrix of the function depends on."
  :long
  (xdoc::topstring
   (xdoc::p
    "When a quantifier second-order function, or an instance thereof,
     is introduced,
     the submitted event form first introduces the function,
     and then checks whether its rewrite rule depends
     exactly on the same function variables
     that the matrix of the function depends on.
     The following code performs this check.")
   (xdoc::p
    "If the check is satisfied, @('nil') is returned.
     Otherwise, an error message is returned.")
   (xdoc::p
    "This check is relevant when the rewrite rule is a custom one.
     Otherwise, it is a redundant check."))
  (let* ((rule-name (defun-sk-rewrite-name fun wrld))
         (rule-body (formula rule-name nil wrld))
         (fun-matrix (defun-sk-matrix fun wrld)))
    (if (set-equiv (funvars-of-term rule-body wrld)
                   (funvars-of-term fun-matrix wrld))
        nil
      (msg "The custom rewrite rule ~x0 must have ~
            the same function variables as the function's matrix ~x1.~%"
           rule-body fun-matrix))))

(define print-funvar-dependency ((fun symbolp)
                                 (kind sofun-kindp)
                                 (wrld plist-worldp))
  :returns (nothing "Always @(tsee null).")
  :mode :program
  :short "Print the function variables that a funcion depends on."
  :long
  (xdoc::topstring
   (xdoc::p
    "When a second-order function, or an instance thereof, is introduced,
     the submitted event form first introduces the function,
     and then prints the function variables that the function depends on.
     The following code performs that printing.")
   (xdoc::p
    "This function returns nothing.
     It is only used for side effects, namely printing.")
   (xdoc::p
    "The @('kind') argument is the kind of @('fun') if second-order,
     otherwise it is the kind of the second-order function
     of which @('fun') is an instance."))
  (let ((funvars (case kind
                   (plain (funvars-of-plain-fn fun wrld))
                   (choice (funvars-of-choice-fn fun wrld))
                   (quant (funvars-of-quantifier-fn fun wrld)))))
    (if funvars
        (cw "The function ~x0 depends on the function variables ~x1.~%"
            fun (remove-duplicates-eq funvars))
      (cw "The function ~x0 depends on no function variables.~%" fun))))

(gen-macro2-of-macro defun)

(gen-macro2-of-macro defund)

(gen-macro2-of-macro defchoose)

(gen-macro2-of-macro defun-sk)

(gen-macro2-of-macro define)

(define check-sothm-inst (sothm-inst (wrld plist-worldp))
  :returns (yes/no "A @(tsee booleanp).")
  :mode :program
  :short "Recognize designations of instances of second-order theorems."
  :long
  (xdoc::topstring-p
   "A designation of an instance of a second-order theorem has the form
    @('(sothm (f1 . g1) ... (fM . gM))'),
    where @('sothm') is a second-order theorem
    and @('((f1 . g1) ... (fM . gM))') is an instantiation.
    These designations are used in @(tsee defthm-inst).")
  (and (true-listp sothm-inst)
       (>= (len sothm-inst) 2)
       (sothmp (car sothm-inst) wrld)
       (funvar-instp (cdr sothm-inst) wrld)))

(define defthm-inst-fn (thm
                        sothm-inst
                        options
                        (ctx "Context for errors.")
                        state)
  :returns (mv (erp "@(tsee booleanp) flag of the
                     <see topic='@(url acl2::error-triple)'>error
                     triple</see>.")
               (event "A @(tsee maybe-pseudo-event-formp).")
               state)
  :mode :program
  :short "Validate some of the inputs to @(tsee defthm-inst)
          and generate the event form to submit."
  :long
  (xdoc::topstring-p
   "We directly check all the inputs except for the @(':rule-classes') option,
    relying on @(tsee defthm) to check it.")
  (b* ((wrld (w state))
       ((unless (symbolp thm))
        (er-soft+ ctx t nil
                  "The first input must be a symbol, but ~x0 is not."
                  thm))
       ((unless (check-sothm-inst sothm-inst wrld))
        (er-soft+ ctx t nil
                  "The second input must be ~
                   the name of a second-order theorem ~
                   followed by the pairs of an instantiation, ~
                   but ~x0 is not."
                  sothm-inst))
       (sothm (car sothm-inst))
       (inst (cdr sothm-inst))
       ((unless (subsetp (alist-keys inst) (funvars-of-thm sothm wrld)))
        (er-soft+ ctx t nil
                  "Each function variable key of ~x0 must be ~
                   among function variable that ~x1 depends on."
                  inst sothm))
       ((unless (keyword-value-listp options))
        (er-soft+ ctx t nil
                  "The inputs after the second input ~
                   must be a keyword-value list, ~
                   but ~x0 is not."
                  options))
       (keywords (evens options))
       ((unless (no-duplicatesp keywords))
        (er-soft+ ctx t nil
                  "The inputs keywords must be unique."))
       ((unless (subsetp keywords '(:rule-classes :print)))
        (er-soft+ ctx t nil
                  "Only the input keywords ~
                   :RULE-CLASSES and :PRINT are allowed."))
       (print-pair (assoc-keyword :print options))
       (print (if print-pair
                  (cadr print-pair)
                :result))
       ((unless (member-eq print '(nil :all :result)))
        (er-soft+ ctx t nil
                  "The :PRINT input must be NIL, :ALL, or :RESULT, ~
                   but ~x0 is not."
                  print))
       (options (remove-keyword :print options))
       (sothm-formula (formula sothm nil wrld))
       (thm-formula (fun-subst-term inst sothm-formula wrld))
       (thm-formula (untranslate thm-formula t wrld))
       (fsbs (ext-fun-subst-term sothm-formula inst wrld))
       (thm-proof (sothm-inst-proof sothm fsbs wrld))
       (defthm-event `(defthm ,thm ,thm-formula ,@thm-proof ,@options))
       (defthm-event-without-proof `(defthm ,thm ,thm-formula ,@options))
       (return-value-event `(value-triple ',thm))
       (event (cond ((eq print nil)
                     `(progn
                        ,defthm-event
                        ,return-value-event))
                    ((eq print :all)
                     (restore-output
                      `(progn
                         ,defthm-event
                         ,return-value-event)))
                    ((eq print :result)
                     `(progn
                        ,defthm-event
                        (cw-event "~x0~|" ',defthm-event-without-proof)
                        ,return-value-event))
                    (t (impossible)))))
    (value event)))

(defsection defthm-inst-implementation
  :short "Implementation of @(tsee defthm-inst)."
  :long
  "@(def defthm-inst)
   @(def acl2::defthm-inst)"

  (defmacro defthm-inst (thm sothminst &rest options)
    `(make-event-terse (defthm-inst-fn
                         ',thm
                         ',sothminst
                         ',options
                         (cons 'defthm-inst ',thm)
                         state)))

  (defmacro acl2::defthm-inst (&rest args)
    `(defthm-inst ,@args)))

(defsection show-defthm-inst
  :short "Show the event form generated by @(tsee defthm-inst),
          without submitting them."
  :long
  "@(def show-defthm-inst)
   @(def acl2::show-defthm-inst)"

  (defmacro show-defthm-inst (thm sothminst &rest options)
    `(defthm-inst-fn
       ',thm
       ',sothminst
       ',options
       (cons 'defthm-inst ',thm)
       state))

  (defmacro acl2::show-defthm-inst (&rest args)
    `(show-defthm-inst ,@args)))

(define check-sofun-inst (sofun-inst (wrld plist-worldp))
  :returns (yes/no "A @(tsee booleanp).")
  :verify-guards nil
  :short "Recognize designations of instances of second-order functions."
  :long
  (xdoc::topstring-p
   "A designation of an instance of a second-order function has the form
    @('(sofun (f1 . g1) ... (fM . gM))'),
    where @('sofun') is a second-order function
    and @('((f1 . g1) ... (fM . gM))') is an instantiation.
    These designations are used in @(tsee defun-inst).")
  (and (true-listp sofun-inst)
       (>= (len sofun-inst) 2)
       (sofunp (car sofun-inst) wrld)
       (funvar-instp (cdr sofun-inst) wrld)))

(define defun-inst-plain-events ((fun symbolp)
                                 (sofun (plain-sofunp sofun (w state)))
                                 inst
                                 (options keyword-value-listp)
                                 (ctx "Context for errors.")
                                 state)
  :returns (mv (erp "@(tsee booleanp) flag of the
                     <see topic='@(url acl2::error-triple)'>error
                     triple</see>.")
               (events+result+funvars
                "A tuple @('(events result funvars)') where
                 @('events') is a @(tsee pseudo-event-form-listp),
                 @('result') is a @(tsee maybe-pseudo-event-formp),
                 and @('funvars') is a @(tsee funvar-listp).")
               state)
  :mode :program
  :short "Generate a list of events to submit,
          when instantiating a plain second-order function."
  :long
  (xdoc::topstring
   (xdoc::p
    "Also return the @(tsee defun2) or @(tsee defun) event form,
     without the termination hints.
     This is printed when @(':print') is @(':result').")
   (xdoc::p
    "Also return the function variables that the new function depends on.")
   (xdoc::p
    "Only the @(':verify-guards'), @(':enable'), and @(':print') options
     may be present.")
   (xdoc::p
    "We add @('fun') to the table of second-order functions
     iff it is second-order.")
   (xdoc::p
    "If @('sofun') (and consequently @('fun')) is recursive,
     we extend the instantiation with @('(sofun . fun)'),
     to ensure that the recursive calls are properly transformed."))
  (b* ((wrld (w state))
       ((unless (subsetp (evens options)
                         '(:verify-guards :enable :print)))
        (er-soft+ ctx t nil
                  "Only the input keywords ~
                   :VERIFY-GUARDS, :ENABLE, and :PRINT are allowed, ~
                   because ~x0 is a plain second-order function."
                  sofun))
       (verify-guards (let ((verify-guards-option
                             (assoc-keyword :verify-guards options)))
                        (if verify-guards-option
                            (cadr verify-guards-option)
                          (guard-verified-p sofun wrld))))
       (enable (let ((enable-option (assoc-keyword :enable options)))
                 (if enable-option
                     (cadr enable-option)
                   (fundef-enabledp sofun state))))
       (sofun-body (ubody sofun wrld))
       (sofun-measure (if (recursivep sofun nil wrld)
                          (measure sofun wrld)
                        nil))
       (sofun-guard (uguard sofun wrld))
       (fsbs (if sofun-measure (acons sofun fun inst) inst))
       (fun-body (fun-subst-term fsbs sofun-body wrld))
       (fun-body-funvars (funvars-of-term fun-body wrld))
       (fun-body (untranslate fun-body nil wrld))
       (fun-measure (fun-subst-term inst sofun-measure wrld))
       (fun-measure-funvars (funvars-of-term fun-measure wrld))
       (fun-measure (untranslate fun-measure nil wrld))
       (fun-guard (fun-subst-term inst sofun-guard wrld))
       (fun-guard-funvars (funvars-of-term fun-guard wrld))
       (fun-guard (untranslate fun-guard t wrld))
       (sofun-tt-name `(:termination-theorem ,sofun))
       (sofun-tt-formula (and (recursivep sofun nil wrld)
                              (termination-theorem sofun wrld)))
       (fsbs (ext-fun-subst-term sofun-tt-formula inst wrld))
       (fun-tt-proof (sothm-inst-proof sofun-tt-name fsbs wrld))
       (hints (if fun-measure `(:hints (("Goal" ,@fun-tt-proof))) nil))
       (measure (if fun-measure `(:measure ,fun-measure) nil))
       (formals (formals sofun wrld))
       (funvars (remove-duplicates (append fun-body-funvars
                                           fun-measure-funvars
                                           fun-guard-funvars)))
       (defun-event `(defun ,fun ,formals
                       (declare (xargs :guard ,fun-guard
                                       :verify-guards ,verify-guards
                                  ,@measure
                                  ,@hints))
                       ,fun-body))
       (result `(,(if funvars 'defun2 'defun)
                 ,fun
                 ,formals
                 (declare (xargs :guard ,fun-guard
                                 :verify-guards ,verify-guards
                            ,@measure))
                 ,fun-body))
       (disable-event?
        (if enable
            nil
          `((in-theory (disable ,fun)))))
       (table-event?
        (if funvars
            `((table second-order-functions ',fun ',funvars))
          nil)))
    (value (list `(,defun-event ,@disable-event? ,@table-event?)
                 result
                 funvars))))

(define defun-inst-choice-events ((fun symbolp)
                                  (sofun (choice-sofunp sofun (w state)))
                                  inst
                                  (options keyword-value-listp)
                                  (ctx "Context for errors.")
                                  state)
  :returns (mv (erp "@(tsee booleanp) flag of the
                     <see topic='@(url acl2::error-triple)'>error
                     triple</see>.")
               (events+result+funvars
                "A tuple @('(events result funvars)') where
                 @('events') is a @(tsee pseudo-event-form-listp),
                 @('result') is a @(tsee maybe-pseudo-event-formp),
                 and @('funvars') is a @(tsee funvar-listp).")
               state)
  :mode :program
  :short "Generate a list of events to submit,
          when instantiating a choice second-order function."
  :long
  (xdoc::topstring
   (xdoc::p
    "Also return the @(tsee defchoose2) or @(tsee defchoose) event form.
     This is printed when @(':print') is @(':result').")
   (xdoc::p
    "Also return the function variables that the new function depends on.")
   (xdoc::p
    "Only the @(':print') option may be present.")
   (xdoc::p
    "We add @('fun') to the table of second-order functions
     iff it is second-order."))
  (b* ((wrld (w state))
       ((unless (subsetp (evens options)
                         '(:print)))
        (er-soft+ ctx t nil
                  "Only the input keyword :PRINT is allowed, ~
                   because ~x0 is a choice second-order function."
                  sofun))
       (bound-vars (defchoose-bound-vars sofun wrld))
       (sofun-body (defchoose-body sofun wrld))
       (fun-body (fun-subst-term inst sofun-body wrld))
       (funvars (funvars-of-term fun-body wrld))
       (fun-body (untranslate fun-body nil wrld))
       (formals (formals sofun wrld))
       (strengthen (defchoose-strengthen sofun wrld))
       (funvars (remove-duplicates funvars))
       (defchoose-event `(defchoose ,fun ,bound-vars ,formals
                           ,fun-body
                           :strengthen ,strengthen))
       (result `(,(if funvars 'defchoose2 'defchoose)
                 ,fun
                 ,bound-vars
                 ,formals
                 ,fun-body
                 :strengthen ,strengthen))
       (table-event?
        (if funvars
            `((table second-order-functions ',fun ',funvars))
          nil)))
    (value (list `(,defchoose-event ,@table-event?)
                 result
                 funvars))))

(define defun-inst-quant-events ((fun symbolp)
                                 (sofun (quant-sofunp sofun (w state)))
                                 inst
                                 (options keyword-value-listp)
                                 (ctx "Context for errors.")
                                 state)
  :returns (mv (erp "@(tsee booleanp) flag of the
                     <see topic='@(url acl2::error-triple)'>error
                     triple</see>.")
               (events+result+funvars
                "A tuple @('(events result funvars)') where
                 @('events') is a @(tsee pseudo-event-form-listp),
                 @('result') is a @(tsee maybe-pseudo-event-formp),
                 and @('funvars') is a @(tsee funvar-listp).")
               state)
  :mode :program
  :short "Generate a list of events to submit,
          when instantiating a quantifier second-order function."
  :long
  (xdoc::topstring
   (xdoc::p
    "Also return the @(tsee defun-sk2) or @(tsee defun-sk) event form.
     This is printed when @(':print') is @(':result').")
   (xdoc::p
    "Also return the function variables that the new function depends on.")
   (xdoc::p
    "Only the
     @(':verify-guards'),
     @(':enable'),
     @(':skolem-name'),
     @(':thm-name'),
     @(':rewrite'),
     @(':constrain'), and
     @(':print')
     options may be present.")
   (xdoc::p
    "We add @('fun') to the table of second-order functions
     iff it is second-order."))
  (b* ((wrld (w state))
       ((unless (subsetp (evens options)
                         '(:verify-guards
                           :enable
                           :skolem-name
                           :thm-name
                           :rewrite
                           :constrain
                           :print)))
        (er-soft+ ctx t nil
                  "Only the input keywords ~
                   :VERIFY-GUARDS, ~
                   :ENABLE, ~
                   :SKOLEM-NAME, ~
                   :THM-NAME,  ~
                   :REWRITE, ~
                   :CONSTRAIN and ~
                   :PRINT ~
                   are allowed, ~
                   because ~x0 is a quantifier second-order function."
                  sofun))
       (enable (let ((enable-option (assoc-keyword :enable options)))
                 (if enable-option
                     (cadr enable-option)
                   (fundef-enabledp sofun state))))
       (verify-guards (let ((verify-guards-option
                             (assoc-keyword :verify-guards options)))
                        (if verify-guards-option
                            (cadr verify-guards-option)
                          (guard-verified-p sofun wrld))))
       (bound-vars (defun-sk-bound-vars sofun wrld))
       (quant (defun-sk-quantifier sofun wrld))
       (sofun-matrix (defun-sk-matrix sofun wrld))
       (fun-matrix (fun-subst-term inst sofun-matrix wrld))
       (fun-matrix-funvars (funvars-of-term fun-matrix wrld))
       (fun-matrix (untranslate fun-matrix nil wrld))
       (rewrite-option (assoc-keyword :rewrite options))
       (rewrite
        (if rewrite-option
            (cadr rewrite-option)
          (let ((qrkind (defun-sk-rewrite-kind sofun wrld)))
            (case qrkind
              (:default :default)
              (:direct :direct)
              (:custom
               (let* ((fsbs (acons sofun fun inst))
                      (rule-name (defun-sk-rewrite-name sofun wrld))
                      (term (formula rule-name nil wrld)))
                 (fun-subst-term fsbs term wrld)))))))
       (skolem-name (let ((skolem-name-option
                           (assoc-keyword :skolem-name options)))
                      (if skolem-name-option
                          `(:skolem-name ,(cadr skolem-name-option))
                        nil)))
       (thm-name (let ((thm-name-option
                        (assoc-keyword :thm-name options)))
                   (if thm-name-option
                       `(:thm-name ,(cadr thm-name-option))
                     nil)))
       (constrain (let ((constrain-option
                         (assoc-keyword :constrain options)))
                    (if constrain-option
                        `(:constrain ,(cadr constrain-option))
                      nil)))
       (sofun-guard (uguard sofun wrld))
       (fun-guard (fun-subst-term inst sofun-guard wrld))
       (fun-guard-funvars (funvars-of-term fun-guard wrld))
       (fun-guard (untranslate fun-guard t wrld))
       (formals (formals sofun wrld))
       (strengthen (defun-sk-strengthen sofun wrld))
       (body (list quant bound-vars fun-matrix))
       (rest `(:strengthen ,strengthen
               :quant-ok t
               ,@(and (eq quant 'forall)
                      (list :rewrite rewrite))
               ,@skolem-name
               ,@thm-name
               ,@constrain))
       (funvars (remove-duplicates (append fun-matrix-funvars
                                           fun-guard-funvars)))
       (defun-sk-event `(defun-sk ,fun ,formals
                          (declare (xargs :guard ,fun-guard
                                          :verify-guards ,verify-guards))
                          ,body
                          ,@rest))
       (result `(,(if funvars 'defun-sk2 'defun-sk)
                 ,fun
                 ,formals
                 ,body
                 ,@rest))
       (disable-event?
        (if enable
            nil
          (let ((fn/defrule (cond ((eq constrain nil) fun)
                                  ((eq constrain t) (add-suffix fun
                                                                "-DEFINITION"))
                                  (t constrain)))
                (rwrule (if thm-name
                            (cadr thm-name)
                          (if (eq quant 'forall)
                              (add-suffix fun "-NECC")
                            (add-suffix fun "-SUFF")))))
            `((in-theory (disable ,fn/defrule ,rwrule))))))
       (table-event?
        (if funvars
            `((table second-order-functions ',fun ',funvars))
          nil))
       (check-event `(make-event-terse
                      (b* ((err-msg?
                            (check-qrewrite-rule-funvars ',sofun (w state))))
                        (if err-msg?
                            (er-soft+
                             (cons 'defun-inst ',fun) t nil "~@0" err-msg?)
                          (value '(value-triple :invisible)))))))
    (value (list `(,defun-sk-event ,@disable-event? ,@table-event? ,check-event)
                 result
                 funvars))))

(define defun-inst-fn (fun
                       sofun-inst
                       options
                       (ctx "Context for errors.")
                       state)
  :returns (mv (erp "@(tsee booleanp) flag of the
                     <see topic='@(url acl2::error-triple)'>error
                     triple</see>.")
               (event "A @(tsee maybe-pseudo-event-formp).")
               state)
  :mode :program
  :short "Validate some of the inputs to @(tsee defun-inst)
          and generate the event form to submit."
  :long
  (xdoc::topstring
   (xdoc::p
    "We directly check the name and instance designation,
     we directly check the correct presence of keyed options
     (we do that in
     @(tsee defun-inst-plain-events),
     @(tsee defun-inst-choice-events), and
     @(tsee defun-inst-quant-events)), and
     we directly check the correct value of the @(':print') option (if present),
     but rely on @(tsee defun), @(tsee defchoose), and @(tsee defun-sk)
     to check the values of the other keyed options.")
   (xdoc::p
    "Prior to introducing @('fun'),
     we generate local events
     to avoid errors due to ignored or irrelevant formals in @('fun')
     (which may happen if @('sofun') has ignored or irrelevant formals).
     We add @('fun') to the table of instances of second-order functions."))
  (b* ((wrld (w state))
       ((unless (symbolp fun))
        (er-soft+ ctx t nil
                  "The first input must be a name, but ~x0 is not."
                  fun))
       ((unless (check-sofun-inst sofun-inst wrld))
        (er-soft+ ctx t nil
                  "The second input must be ~
                   the name of a second-order function ~
                   followed by the pairs of an instantiation, ~
                   but ~x0 is not."
                  sofun-inst))
       (sofun (car sofun-inst))
       (inst (cdr sofun-inst))
       ((unless (subsetp (alist-keys inst) (sofun-funvars sofun wrld)))
        (er-soft+ ctx t nil
                  "Each function variable key of ~x0 must be ~
                   among the function variables ~x1 ~
                   that ~x2 depends on."
                  inst (sofun-funvars sofun wrld) sofun))
       ((unless (keyword-value-listp options))
        (er-soft+ ctx t nil
                  "The inputs after the second input ~
                   must be a keyword-value list, ~
                   but ~x0 is not."
                  options))
       (keywords (evens options))
       ((unless (no-duplicatesp keywords))
        (er-soft+ ctx t nil
                  "The input keywords must be unique."))
       (print-pair (assoc-keyword :print options))
       (print (if print-pair
                  (cadr print-pair)
                :result))
       ((unless (member-eq print '(nil :all :result)))
        (er-soft+ ctx t nil
                  "The :PRINT input must be NIL, :ALL, or :RESULT, ~
                   but ~x0 is not."
                  print))
       ((er (list fun-intro-events result funvars))
        (case (sofun-kind sofun wrld)
          (plain
           (defun-inst-plain-events fun sofun inst options ctx state))
          (choice
           (defun-inst-choice-events fun sofun inst options ctx state))
          (quant
           (defun-inst-quant-events fun sofun inst options ctx state))
          (t (prog2$ (impossible) (value (list nil nil))))))
       (instmap (sof-instances sofun wrld))
       (new-instmap (put-sof-instance inst fun instmap wrld))
       (encapsulate
         `(encapsulate
            ()
            (set-ignore-ok t)
            (set-irrelevant-formals-ok t)
            ,@fun-intro-events
            (table sof-instances ',sofun ',new-instmap)))
       (result-event `(cw-event "~x0~|" ',result))
       (print-funvar-event
        (if funvars
            `(cw-event
              "The function ~x0 depends on the function variables ~x1.~%"
              ',fun ',funvars)
          `(cw-event "The function ~x0 depends on no function variables.~%"
                     ',fun)))
       (return-value-event `(value-triple ',fun))
       (event (cond ((eq print nil)
                     `(progn
                        ,encapsulate
                        ,print-funvar-event
                        ,return-value-event))
                    ((eq print :all)
                     (restore-output
                      `(progn
                         ,encapsulate
                         ,print-funvar-event
                         ,return-value-event)))
                    ((eq print :result)
                     `(progn
                        ,encapsulate
                        ,result-event
                        ,print-funvar-event
                        ,return-value-event))
                    (t (impossible)))))
    (value event)))

(defsection defun-inst-implementation
  :short "Implementation of @(tsee defun-inst)."
  :long
  "@(def defun-inst)
   @(def acl2::defun-inst)"

  (defmacro defun-inst (fun sofun-inst &rest rest)
    `(make-event-terse (defun-inst-fn
                         ',fun
                         ',sofun-inst
                         ',rest
                         (cons 'defun-inst ',fun)
                         state)))

  (defmacro acl2::defun-inst (&rest args)
    `(defun-inst ,@args)))

(defsection show-defun-inst
  :short "Show the event form generated by @(tsee defun-inst),
          without submitting them."
  :long
  "@(def show-defun-inst)
   @(def acl2::show-defun-inst)"

  (defmacro show-defun-inst (fun sofun-inst &rest rest)
    `(defun-inst-fn
       ',fun
       ',sofun-inst
       ',rest
       (cons 'defun-inst ',fun)
       state))

  (defmacro acl2::show-defun-inst (&rest args)
    `(show-defun-inst ,@args)))
