; Java Library
;
; Copyright (C) 2019 Kestrel Institute (http://www.kestrel.edu)
;
; License: A 3-clause BSD license. See the LICENSE file distributed with ACL2.
;
; Author: Alessandro Coglio (coglio@kestrel.edu)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package "JAVA")

(include-book "types")

(include-book "ihs/basic-definitions" :dir :system)
(include-book "kestrel/java/language/primitive-values" :dir :system)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defrulel sbyte32p-of-logext32
  (acl2::sbyte32p (acl2::logext 32 x))
  :enable acl2::sbyte32p
  :prep-books ((include-book "arithmetic-5/top" :dir :system)))

(in-theory (disable acl2::logext))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defxdoc+ atj-primitives
  :parents (atj-implementation)
  :short "Representation of Java primitive types and operations for ATJ."
  :long
  (xdoc::topstring
   (xdoc::p
    "In order to have generate Java code that manipulates Java types,
     we need ACL2 functions that correspond to
     the Java primitive values and operations:
     when ATJ encounters these specific ACL2 functions,
     it can translate them to corresponding Java constructs
     that operate on primitive types.
     When deriving a Java implementation from a specification,
     where ATJ is used as the last step of the derivation,
     the steps just before the last one can refine things
     to use the aforementioned ACL2 functions,
     ideally using " (xdoc::seetopic "apt::apt" "APT") " transformations,
     so that ATJ can produce Java code
     that operates on primitive types where needed.
     These steps just before the last could perhaps be somewhat automated,
     and incorporated into a code generation step that actually encompasses
     some ACL2-to-ACL2 transformation steps
     before the final ACL2-to-Java step.")
   (xdoc::p
    "The natural place for these ACL2 functions is the "
    (xdoc::seetopic "language" "language formalization")
    " that is being developed.
     This formalization currently includes primitive values,
     but not operations on primitive values yet.
     So here we add a quick formalization of a few primitive operations,
     for the purpose of experimenting with having ATJ
     generate Java code that operates on primitive types.
     As the language formalization is extended with Java primitive operations
     (expected to be better and more thorough than the quick ones here),
     they will replace the quick ones here, which will be eventually removed.")
   (xdoc::p
    "Needless to say, here `primitive' refers to
     Java primitive types, values, and operations.
     It has nothing to do with the ACL2 primitive functions."))
  :order-subtopics t
  :default-parent t)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defsection atj-jint-representation-check
  :short "Checking the representation of Java @('int') values."
  :long
  (xdoc::topstring
   (xdoc::p
    "The type @(tsee int-value)
     provides the representation of Java @('int') values in ACL2
     which ATJ must map to Java @('int') values.
     While values of that ACL2 type can be treated abstractly,
     nothing prevents the use of ACL2 operations on it
     that expose its internal structure, e.g. taking the @(tsee car).
     Thus, Java code generated by ATJ must, if needed,
     convert Java @('int') values to
     the Java representation of their ACL2 representation,
     namely the Java representation of the @(tsee int-value) representation.")
   (xdoc::p
    "The following theorem ensures that @(tsee int-value)
     has a certain representation,
     so that ATJ can use the same representation,
     for correctness and consistency."))

  (defrule atj-int-value-representation-check
    (equal (int-value-p x)
           (and (tuplep 2 x)
                (eq (first x) :int)
                (acl2::sbyte32p (second x))))
    :rule-classes nil
    :enable int-value-p))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define jint-plus ((x int-value-p))
  :returns (z int-value-p)
  :short "Unary plus of integers [JLS:4.2.2] [JLS:15.15.3]."
  (b* ((x (int-value->int x))
       (z (acl2::logext 32 (+ x))))
    (int-value z)))

(define jint-minus ((x int-value-p))
  :returns (z int-value-p)
  :short "Unary minus of integers [JLS:4.2.2] [JLS:15.15.4]."
  (b* ((x (int-value->int x))
       (z (acl2::logext 32 (- x))))
    (int-value z)))

(define jint-not ((x int-value-p))
  :returns (z int-value-p)
  :short "Bitwise complement of integers [JLS:4.2.2] [JLS:15.5.5]."
  (b* ((x (int-value->int x))
       (z (acl2::logext 32 (lognot x))))
    (int-value z)))

(define jint-add ((x int-value-p) (y int-value-p))
  :returns (z int-value-p)
  :short "Addition of Java @('int') values [JLS:4.2.2] [JLS:15.18.2]."
  (b* ((x (int-value->int x))
       (y (int-value->int y))
       (z (acl2::logext 32 (+ x y))))
    (int-value z)))

(define jint-sub ((x int-value-p) (y int-value-p))
  :returns (z int-value-p)
  :short "Subtraction of Java @('int') values [JLS:4.2.2] [JLS:15.18.2]."
  (b* ((x (int-value->int x))
       (y (int-value->int y))
       (z (acl2::logext 32 (- x y))))
    (int-value z)))

(define jint-mul ((x int-value-p) (y int-value-p))
  :returns (z int-value-p)
  :short "Multiplication of Java @('int') values [JLS:4.2.2] [JLS:15.17.1]."
  (b* ((x (int-value->int x))
       (y (int-value->int y))
       (z (acl2::logext 32 (* x y))))
    (int-value z)))

(define jint-div ((x int-value-p) (y int-value-p))
  :guard (not (equal (int-value->int y) 0))
  :returns (z int-value-p)
  :short "Division of Java @('int') values [JLS:4.2.2] [JLS:15.17.2]."
  (b* ((x (int-value->int x))
       (y (int-value->int y))
       (z (acl2::logext 32 (truncate x y))))
    (int-value z)))

(define jint-rem ((x int-value-p) (y int-value-p))
  :guard (not (equal (int-value->int y) 0))
  :returns (z int-value-p)
  :short "Remainder of Java @('int') values [JLS:4.2.2] [JLS:15.17.3]."
  (b* ((x (int-value->int x))
       (y (int-value->int y))
       (z (acl2::logext 32 (rem x y))))
    (int-value z)))

(define jint-and ((x int-value-p) (y int-value-p))
  :returns (z int-value-p)
  :short "Bitwise `and' of Java @('int') values [JLS:4.2.2] [JLS:15.22.1]."
  (b* ((x (int-value->int x))
       (y (int-value->int y))
       (z (acl2::logext 32 (logand x y))))
    (int-value z)))

(define jint-ior ((x int-value-p) (y int-value-p))
  :returns (z int-value-p)
  :short "Bitwise inclusive `or' of Java @('int') values
          [JLS:4.2.2] [JLS:15.22.1]."
  (b* ((x (int-value->int x))
       (y (int-value->int y))
       (z (acl2::logext 32 (logior x y))))
    (int-value z)))

(define jint-xor ((x int-value-p) (y int-value-p))
  :returns (z int-value-p)
  :short "Bitwise exclusive `or' of Java @('int') values
          [JLS:4.2.2] [JLS:15.22.1]."
  (b* ((x (int-value->int x))
       (y (int-value->int y))
       (z (acl2::logext 32 (logxor x y))))
    (int-value z)))

(define jint-eq ((x int-value-p) (y int-value-p))
  :returns (z boolean-value-p)
  :short "Equality of Java @('int') values [JLS:4.2.2] [JLS:15.21.1]."
  (b* ((x (int-value->int x))
       (y (int-value->int y))
       (z (equal x y)))
    (boolean-value z)))

(define jint-ne ((x int-value-p) (y int-value-p))
  :returns (z boolean-value-p)
  :short "Non-equality of Java @('int') values [JLS:4.2.2] [JLS:15.21.1]."
  (b* ((x (int-value->int x))
       (y (int-value->int y))
       (z (not (equal x y))))
    (boolean-value z)))

(define jint-lt ((x int-value-p) (y int-value-p))
  :returns (z boolean-value-p)
  :short "Less-than comparison of Java @('int') values
          [JLS:4.2.2] [JLS:15.20.1]."
  (b* ((x (int-value->int x))
       (y (int-value->int y))
       (z (< x y)))
    (boolean-value z)))

(define jint-le ((x int-value-p) (y int-value-p))
  :returns (z boolean-value-p)
  :short "Less-than-or-equal-to comparison of Java @('int') values
          [JLS:4.2.2] [JLS:15.20.1]."
  (b* ((x (int-value->int x))
       (y (int-value->int y))
       (z (<= x y)))
    (boolean-value z)))

(define jint-gt ((x int-value-p) (y int-value-p))
  :returns (z boolean-value-p)
  :short "Greater-than comparison of Java @('int') values
          [JLS:4.2.2] [JLS:15.20.1]."
  (b* ((x (int-value->int x))
       (y (int-value->int y))
       (z (> x y)))
    (boolean-value z)))

(define jint-ge ((x int-value-p) (y int-value-p))
  :returns (z boolean-value-p)
  :short "Greater-than-or-equal-to comparison of Java @('int') values
          [JLS:4.2.2] [JLS:15.20.1]."
  (b* ((x (int-value->int x))
       (y (int-value->int y))
       (z (>= x y)))
    (boolean-value z)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defval *atj-primitive-constructors*
  :short "List of (the names of) the ACL2 functions that model
          the construction of Java primitive types."
  :long
  (xdoc::topstring
   (xdoc::p
    "For now the list only consists of @(tsee int-value).
     More will be added as ATJ support for Java primitive types is extended."))
  '(int-value)
  ///
  (assert-event (symbol-listp *atj-primitive-constructors*))
  (assert-event (no-duplicatesp-eq *atj-primitive-constructors*)))

(defval *atj-primitive-binops*
  :short "List of (the names of) the ACL2 functions that model
          Java primitive binary operations."
  :long
  (xdoc::topstring
   (xdoc::p
    "For now we list only some of the available ones.
     As more ATJ support for Java primitive types is developed,
     the list will be extended with more of the available functions,
     as well as with new functions."))
  '(jint-add
    jint-sub
    jint-mul
    jint-div
    jint-rem)
  ///
  (assert-event (symbol-listp *atj-primitive-binops*))
  (assert-event (no-duplicatesp-eq *atj-primitive-binops*)))

(defval *atj-primitive-fns*
  :short "List of (the names of) the ACL2 functions that model
          Java primitive value constructions and operations."
  (append *atj-primitive-constructors*
          *atj-primitive-binops*)
  ///
  (assert-event (symbol-listp *atj-primitive-fns*))
  (assert-event (no-duplicatesp-eq *atj-primitive-fns*)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defsection atj-types-for-primitivess
  :short "ATJ types for the Java primitive constructors and operations."

  (def-atj-main-function-type int-value (:ainteger) :jint)

  (def-atj-main-function-type jint-plus (:jint) :jint)

  (def-atj-main-function-type jint-minus (:jint) :jint)

  (def-atj-main-function-type jint-not (:jint) :jint)

  (def-atj-main-function-type jint-add (:jint :jint) :jint)

  (def-atj-main-function-type jint-sub (:jint :jint) :jint)

  (def-atj-main-function-type jint-mul (:jint :jint) :jint)

  (def-atj-main-function-type jint-div (:jint :jint) :jint)

  (def-atj-main-function-type jint-rem (:jint :jint) :jint)

  (def-atj-main-function-type jint-and (:jint :jint) :jint)

  (def-atj-main-function-type jint-ior (:jint :jint) :jint)

  (def-atj-main-function-type jint-xor (:jint :jint) :jint))
