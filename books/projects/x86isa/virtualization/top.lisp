(in-package "X86ISA")

(include-book "tools/include-raw" :dir :system)
(include-book "../machine/state")

(defun write-val1 (size)
  (declare (xargs :mode :program))
  (if (equal size 0)
      nil
      (cons `((mv ?val state) (b* ((state (write-byte$ (logand #xFF val) channel state)))
                                 (mv (ash val -8) state)))
            (write-val1 (- size 8)))))

(defmacro write-val (val size channel state)
  `(b* ((val ,val)
        (state ,state)
        (channel ,channel)
        ,@(write-val1 size))
       state))

(defmacro write-packed-struct (struct channel state)
  (if (not struct)
      state
      (b* (((list* (list size val) tail) struct))
          `(b* ((state (write-val ,val ,size ,channel ,state)))
               (write-packed-struct ,tail ,channel state)))))

(defun write-bytes (bytes channel state)
  (declare (xargs :stobjs (state)
                  :mode :program))
  (b* (((when (not bytes)) state)
       ((cons b tail) bytes)
       (state (write-byte$ b channel state)))
      (write-bytes tail channel state)))

(defun write-page (i1 i2 content channel state)
  (declare (xargs :stobjs (state)
                  :mode :program))
  (b* ((state (write-val (logapp 22 i2 i1) 64 channel state))
       (state (write-bytes content channel state)))
      state))

(defun write-l2s (l2s i1 channel state)
  (declare (xargs :stobjs (state)
                  :mode :program))
  (b* (((when (not l2s)) state)
       ((cons (cons i2 content) tail) l2s)
       (state (write-page i1 i2 (reverse content) channel state)))
      (write-l2s tail i1 channel state)))

(defun write-l1 (l1 channel state)
  (declare (xargs :stobjs (state)
                  :mode :program))
  (b* (((cons i1 l2s) l1))
      (write-l2s l2s i1 channel state)))

;; This should write an array of mem_file_element
(defun write-mem (serialized-mem channel state)
  (declare (xargs :stobjs (state)
                  :mode :program))
  (if (equal serialized-mem nil)
      state
      (b* ((state (write-l1 (car serialized-mem) channel state)))
          (write-mem (cdr serialized-mem) channel state))))

(defun dump-virtualizable-state (filename x86 state)
  (declare (xargs :stobjs (x86 state)
                  :mode :program))
                  
  (b* (((mv channel state) (open-output-channel filename :byte state))
       ;; This should match state_file in main.c
       (state (write-packed-struct ((64 (rgfi 0 x86))
                                    (64 (rgfi 1 x86))
                                    (64 (rgfi 2 x86))
                                    (64 (rgfi 3 x86))
                                    (64 (rgfi 4 x86))
                                    (64 (rgfi 5 x86))
                                    (64 (rgfi 6 x86))
                                    (64 (rgfi 7 x86))
                                    (64 (rgfi 8 x86))
                                    (64 (rgfi 9 x86))
                                    (64 (rgfi 10 x86))
                                    (64 (rgfi 11 x86))
                                    (64 (rgfi 12 x86))
                                    (64 (rgfi 13 x86))
                                    (64 (rgfi 14 x86))
                                    (64 (rgfi 15 x86))
                                    (64 (rip x86))
                                    (32 (rflags x86))
                                    (16 (seg-visiblei *cs* x86))
                                    (64 (seg-hidden-basei *cs* x86))
                                    (32 (seg-hidden-limiti *cs* x86))
                                    (16 (seg-hidden-attri *cs* x86))
                                    (16 (seg-visiblei *ds* x86))
                                    (64 (seg-hidden-basei *ds* x86))
                                    (32 (seg-hidden-limiti *ds* x86))
                                    (16 (seg-hidden-attri *ds* x86))
                                    (16 (seg-visiblei *es* x86))
                                    (64 (seg-hidden-basei *es* x86))
                                    (32 (seg-hidden-limiti *es* x86))
                                    (16 (seg-hidden-attri *es* x86))
                                    (16 (seg-visiblei *fs* x86))
                                    (64 (seg-hidden-basei *fs* x86))
                                    (32 (seg-hidden-limiti *fs* x86))
                                    (16 (seg-hidden-attri *fs* x86))
                                    (16 (seg-visiblei *gs* x86))
                                    (64 (seg-hidden-basei *gs* x86))
                                    (32 (seg-hidden-limiti *gs* x86))
                                    (16 (seg-hidden-attri *gs* x86))
                                    (16 (seg-visiblei *ss* x86))
                                    (64 (seg-hidden-basei *ss* x86))
                                    (32 (seg-hidden-limiti *ss* x86))
                                    (16 (seg-hidden-attri *ss* x86))
                                    (16 (ssr-visiblei *tr* x86))
                                    (64 (ssr-hidden-basei *tr* x86))
                                    (32 (ssr-hidden-limiti *tr* x86))
                                    (16 (ssr-hidden-attri *tr* x86))
                                    (16 (ssr-visiblei *ldtr* x86))
                                    (64 (ssr-hidden-basei *ldtr* x86))
                                    (32 (ssr-hidden-limiti *ldtr* x86))
                                    (16 (ssr-hidden-attri *ldtr* x86))
                                    (80 (stri *gdtr* x86))
                                    (80 (stri *idtr* x86))
                                    (64 (ctri *cr0* x86))
                                    (64 (ctri *cr2* x86))
                                    (64 (ctri *cr3* x86))
                                    (64 (ctri *cr4* x86))
                                    (64 (ctri *cr8* x86))
                                    (64 (msri *ia32_efer-idx* x86))
                                    (64 (msri *ia32_fs_base-idx* x86))
                                    (64 (msri *ia32_gs_base-idx* x86)))
                                   channel
                                   state))
       (state (write-mem (serialize-mem x86) channel state))
       (state (close-output-channel channel state)))
      state))

(defun validate-inst (x86)
  (declare (xargs :stobjs (x86)
                  :mode :program))
  (mv nil x86))

;; validate-insts will not try to validate instructions
;; when the RIP is in a hole
;; This is a list of conses where each cons is the min
;; and max address of the hole
(defconst *validate-inst-holes* '((#x9e030 . #x9e050)))

(defun addr-in-hole-fn (addr holes)
  (declare (xargs :mode :program))
  (b* (((when (not holes)) nil)
       ((list* (cons min max) tail) holes)
       ((when (and (>= addr min)
                   (<= addr max))) t))
      (addr-in-hole-fn addr tail)))

(defmacro addr-in-hole (addr)
  `(addr-in-hole-fn ,addr *validate-inst-holes*))

(defun run-until-rip-change-outside-hole (x86)
  (declare (xargs :stobjs (x86)
                  :mode :program))
  (b* ((old-rip (rip x86))
       (x86 (x86-fetch-decode-execute x86))
       ((when (or (equal old-rip (rip x86))
                  (addr-in-hole (rip x86)))) (run-until-rip-change-outside-hole x86)))
      x86))

(defun run-until-rip-or-n-outside-holes-fn (rip n m x86)
  (declare (xargs :stobjs (x86)
                  :mode :program))
  (b* (((when (equal n m)) (mv nil m x86))
       ((when (or (ms x86)
                  (fault x86))) (mv nil m x86))
       ((when (equal (rip x86)
                     (i64 rip))) (mv t m x86))
       (x86 (run-until-rip-change-outside-hole x86)))
      (run-until-rip-or-n-outside-holes-fn rip n (1+ m) x86)))

(defmacro run-until-rip-or-n-outside-holes (rip n x86)
  `(run-until-rip-or-n-outside-holes-fn ,rip ,n 0 ,x86))

(defun validate-insts (n x86)
  (declare (xargs :stobjs (x86)
                  :mode :program))
  (b* (((when (equal n 0)) (mv t n x86))
       ((mv success? x86) (validate-inst x86))
       ((when (not success?)) (mv nil n x86)))
      (validate-insts (1- n) x86)))

(defttag :include-raw)
(include-raw "virtualization-raw.lisp")
