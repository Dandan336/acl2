; APT (Automated Program Transformations) Library
;
; Copyright (C) 2020 Kestrel Institute (http://www.kestrel.edu)
;
; License: A 3-clause BSD license. See the LICENSE file distributed with ACL2.
;
; Author: Alessandro Coglio (coglio@kestrel.edu)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package "APT")

(include-book "defaults-table")

(include-book "kestrel/error-checking/ensure-value-is-boolean" :dir :system)
(include-book "kestrel/error-checking/ensure-value-is-symbol" :dir :system)
(include-book "kestrel/utilities/error-checking/top" :dir :system)
(include-book "xdoc/defxdoc-plus" :dir :system)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defxdoc+ input-processors
  :parents (utilities)
  :short "Utilities to process inputs
          that are common to multiple APT transformations."
  :default-parent t)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define process-input-new-name (new-name (old symbolp) ctx state)
  :returns (mv erp (new-name$ "A @(tsee symbolp).") state)
  :mode :program
  :short "Process the @(':new-name') input of an APT transformation."
  :long
  (xdoc::topstring
   (xdoc::p
    "The @(':new-name') input of an APT transformations must be
     either @(':auto') or another (non-keyword) symbol.
     In the first case, the name of the new function
     is obtained from the name of the old function (in the argument @('old')),
     by incrementing its (explicit or implicit) numbered name index.
     In the second case, the name of the new function
     is the directly specified symbol,
     which must therefore be a valid name for a new function."))
  (b* (((er &) (ensure-value-is-symbol$ new-name "The :NEW-NAME input" t nil))
       (new-name (case new-name
                   (:auto (next-numbered-name old (w state)))
                   (t new-name)))
       (description (msg "The name ~x0 of the new function, ~@1,"
                         new-name
                         (if (eq new-name :auto)
                             "automatically generated ~
                              since the :NEW-NAME input ~
                              is (perhaps by default) :AUTO"
                           "supplied as the :NEW-NAME input")))
       ((er &) (ensure-symbol-new-event-name$ new-name description t nil)))
    (value new-name)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define process-old-to-new-name (old-to-new-name
                                 (old-to-new-name-present booleanp)
                                 (old symbolp)
                                 (new symbolp)
                                 (names-to-avoid symbol-listp)
                                 ctx
                                 state)
  :returns (mv erp
               (result "A list @('(old-to-new new-names-to-avoid)')
                        satisfying
                        @('(typed-tuplep symbolp symbol-listp result)').")
               state)
  :mode :program
  :short "Process the @(':old-to-new-name') input of an APT transformation."
  :long
  (xdoc::topstring
   (xdoc::p
    "The APT transformations that use this utility
     have an input @(':old-to-new-name')
     that specifies the name of the generated theorem
     that rewrites the old function in terms of the new function.
     This input must be either a symbol to use directly as the theorem name
     (in which case the symbol must not be a keyword),
     or a keyword used as a separator
     between the names of the old and new functions
     as expained in @(tsee set-default-input-old-to-new-name).
     If also explained there, if this input is absent,
     it is taken from the APT defaults table.")
   (xdoc::p
    "This utility processed the @(':old-to-new-name') input
     of an APT transformation,
     validating that the input specifies a valid name
     for the new theorem.
     The @('names-to-avoid') parameter contains names of other events
     that are generated by the transformation but do not yet exist:
     they are used to ensure that the name of this theorem
     is distinct from them;
     this theorem's name is added to the list, which is also returned.")
   (xdoc::p
    "The caller of this utility must set
     the parameter @('old-to-new-name-present') to @('t')
     iff the @(':old-to-new-name') input is present.
     If this is @('nil'), the parameter @('old-to-new-name') is ignored."))
  (b* ((wrld (w state))
       ((er &) (if old-to-new-name-present
                   (ensure-value-is-symbol$ old-to-new-name
                                            "The :OLD-TO-NEW-NAME input"
                                            t
                                            nil)
                 (value nil)))
       (name (if (or (not old-to-new-name-present)
                     (keywordp old-to-new-name))
                 (b* ((kwd (if old-to-new-name-present
                               old-to-new-name
                             (get-default-input-old-to-new-name wrld))))
                   (intern-in-package-of-symbol
                    (concatenate 'string
                                 (symbol-name old)
                                 (symbol-name kwd)
                                 (symbol-name new))
                    new))
               old-to-new-name))
       (description (msg "The name ~x0 of the theorem ~
                          that rewrites the old function ~x1 ~
                          in terms of the new function ~x2, ~
                          specified (perhaps by default) ~
                          by the :OLD-TO-NEW-NAME input ~x3,"
                         name old new old-to-new-name))
       (error-msg? (fresh-namep-msg-weak name nil wrld))
       ((when error-msg?)
        (er-soft+ ctx t nil
                  "~@0 must be a valid fresh theorem name.  ~@1"
                  description error-msg?))
       ((er &) (ensure-not-member-of-list$
                name
                names-to-avoid
                (msg "among the names ~x0 of other events ~
                      generated by this transformation"
                     names-to-avoid)
                description
                t
                nil)))
    (value (list name (cons name names-to-avoid)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define process-new-to-old-name (new-to-old-name
                                 (new-to-old-name-present booleanp)
                                 (old symbolp)
                                 (new symbolp)
                                 (names-to-avoid symbol-listp)
                                 ctx
                                 state)
  :returns (mv erp
               (result "A list @('(new-to-old new-names-to-avoid)')
                        satisfying
                        @('(typed-tuplep symbolp symbol-listp result)').")
               state)
  :mode :program
  :short "Process the @(':new-to-old-name') input of an APT transformation."
  :long
  (xdoc::topstring-p
   "This is quite analogous to @(tsee process-old-to-new-name),
    but for the @(':new-to-old-name') input of an APT transformation.")
  (b* ((wrld (w state))
       ((er &) (if new-to-old-name-present
                   (ensure-value-is-symbol$ new-to-old-name
                                            "The :NEW-TO-OLD-NAME input"
                                            t
                                            nil)
                 (value nil)))
       (name (if (or (not new-to-old-name-present)
                     (keywordp new-to-old-name))
                 (b* ((kwd (if new-to-old-name-present
                               new-to-old-name
                             (get-default-input-new-to-old-name wrld))))
                   (intern-in-package-of-symbol
                    (concatenate 'string
                                 (symbol-name new)
                                 (symbol-name kwd)
                                 (symbol-name old))
                    new))
               new-to-old-name))
       (description (msg "The name ~x0 of the theorem ~
                          that rewrites the new function ~x1 ~
                          in terms of the old function ~x2, ~
                          specified (perhaps by default) ~
                          by the :NEW-TO-OLD-NAME input ~x3,"
                         name new old new-to-old-name))
       (error-msg? (fresh-namep-msg-weak name nil wrld))
       ((when error-msg?)
        (er-soft+ ctx t nil
                  "~@0 must be a valid fresh theorem name.  ~@1"
                  description error-msg?))
       ((er &) (ensure-not-member-of-list$
                name
                names-to-avoid
                (msg "among the names ~x0 of other events ~
                      generated by this transformation"
                     names-to-avoid)
                description
                t
                nil)))
    (value (list name (cons name names-to-avoid)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define process-old-to-new-enable (old-to-new-enable
                                   (old-to-new-enable-present booleanp)
                                   ctx
                                   state)
  :returns (mv erp (old-to-new booleanp) state)
  :short "Process the @(':old-to-new-enable') input of an APT transformation."
  :long
  (xdoc::topstring
   (xdoc::p
    "The APT transformations that use this utility
     have an @(':old-to-new-enable') input
     that specifies whether to enable or not
     the theorem that rewrites the old function in terms of the new function.
     This must be a boolean.
     If absent, it is taken from the APT defaults table;
     see @(tsee set-default-input-old-to-new-enable).")
   (xdoc::p
    "The caller of this utility must set
     the parameter @('old-to-new-enable-present') to @('t')
     iff the @(':old-to-new-enable') input is present.
     If this is @('nil'), the parameter @('old-to-new-enable') is ignored."))
  (if old-to-new-enable-present
      (b* (((er &) (ensure-value-is-boolean$ old-to-new-enable
                                             "The :OLD-TO-NEW-ENABLE input"
                                             t
                                             nil)))
        (value old-to-new-enable))
    (value (get-default-input-old-to-new-enable (w state))))
  :prepwork ((local (in-theory (enable acl2::ensure-value-is-boolean)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define process-new-to-old-enable (new-to-old-enable
                                   (new-to-old-enable-present booleanp)
                                   ctx
                                   state)
  :returns (mv erp (new-to-old booleanp) state)
  :short "Process the @(':new-to-old-enable') input of an APT transformation."
  :long
  (xdoc::topstring-p
   "This is quite analogous to @(tsee process-old-to-new-enable),
    but for the @(':new-to-old-enable') input of an APT transformation.")
  (if new-to-old-enable-present
      (b* (((er &) (ensure-value-is-boolean$ new-to-old-enable
                                             "The :NEW-TO-OLD-ENABLE input"
                                             t
                                             nil)))
        (value new-to-old-enable))
    (value (get-default-input-new-to-old-enable (w state))))
  :prepwork ((local (in-theory (enable acl2::ensure-value-is-boolean)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define process-old-to-wrapper-name (old-to-wrapper-name
                                     (old-to-wrapper-name-present booleanp)
                                     (gen-wrapper booleanp)
                                     (old symbolp)
                                     (wrapper symbolp)
                                     (names-to-avoid symbol-listp)
                                     ctx
                                     state)
  :returns (mv erp
               (result "A list @('(old-to-wrapper new-names-to-avoid)')
                        satisfying
                        @('(typed-tuplep symbolp symbol-listp result)').")
               state)
  :mode :program
  :short "Process the @(':old-to-wrapper-name') input of an APT transformation."
  :long
  (xdoc::topstring-p
   "This is quite analogous to @(tsee process-old-to-new-name),
    but for the @(':old-to-wrapper-name') input of an APT transformation.
    The @('gen-wrapper') parameter is @('t') iff the wrapper is generated,
    i.e. if the @(':wrapper') input of the transformation is @('t').
    If this is @('nil'), we ensure that @(':old-to-wrapper-name') is absent.")
  (if gen-wrapper
      (b* ((wrld (w state))
           ((er &) (if old-to-wrapper-name-present
                       (ensure-value-is-symbol$ old-to-wrapper-name
                                                "The :OLD-TO-WRAPPER-NAME input"
                                                t
                                                nil)
                     (value nil)))
           (name (if (or (not old-to-wrapper-name-present)
                         (keywordp old-to-wrapper-name))
                     (b* ((kwd (if old-to-wrapper-name-present
                                   old-to-wrapper-name
                                 (get-default-input-old-to-wrapper-name wrld))))
                       (intern-in-package-of-symbol
                        (concatenate 'string
                                     (symbol-name old)
                                     (symbol-name kwd)
                                     (symbol-name wrapper))
                        wrapper))
                   old-to-wrapper-name))
           (description (msg "The name ~x0 of the theorem ~
                              that rewrites the old function ~x1 ~
                              in terms of the wrapper function ~x2, ~
                              specified (perhaps by default) ~
                              by the :OLD-TO-WRAPPER-NAME input ~x3,"
                             name old wrapper old-to-wrapper-name))
           (error-msg? (fresh-namep-msg-weak name nil wrld))
           ((when error-msg?)
            (er-soft+ ctx t nil
                      "~@0 must be a valid fresh theorem name.  ~@1"
                      description error-msg?))
           ((er &) (ensure-not-member-of-list$
                    name
                    names-to-avoid
                    (msg "among the names ~x0 of other events ~
                          generated by this transformation"
                         names-to-avoid)
                    description
                    t
                    nil)))
        (value (list name (cons name names-to-avoid))))
    (if old-to-wrapper-name-present
        (er-soft+ ctx t nil
                  "Since the :WRAPPER input is (perhaps by default) NIL, ~
                   no :OLD-TO-WRAPPER-NAME input may be supplied,
                   but ~x0 was supplied instead."
                  old-to-wrapper-name)
      (value (list nil names-to-avoid)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define process-wrapper-to-old-name (wrapper-to-old-name
                                     (wrapper-to-old-name-present booleanp)
                                     (gen-wrapper booleanp)
                                     (old symbolp)
                                     (wrapper symbolp)
                                     (names-to-avoid symbol-listp)
                                     ctx
                                     state)
  :returns (mv erp
               (result "A list @('(wrapper-to-old new-names-to-avoid)')
                        satisfying
                        @('(typed-tuplep symbolp symbol-listp result)').")
               state)
  :mode :program
  :short "Process the @(':wrapper-to-old-name') input of an APT transformation."
  :long
  (xdoc::topstring-p
   "This is quite analogous to @(tsee process-old-to-wrapper-name),
    but for the @(':wrapper-to-old-name') input of an APT transformation.")
  (if gen-wrapper
      (b* ((wrld (w state))
           ((er &) (if wrapper-to-old-name-present
                       (ensure-value-is-symbol$ wrapper-to-old-name
                                                "The :WRAPPER-TO-OLD-NAME input"
                                                t
                                                nil)
                     (value nil)))
           (name (if (or (not wrapper-to-old-name-present)
                         (keywordp wrapper-to-old-name))
                     (b* ((kwd (if wrapper-to-old-name-present
                                   wrapper-to-old-name
                                 (get-default-input-wrapper-to-old-name wrld))))
                       (intern-in-package-of-symbol
                        (concatenate 'string
                                     (symbol-name wrapper)
                                     (symbol-name kwd)
                                     (symbol-name old))
                        wrapper))
                   wrapper-to-old-name))
           (description (msg "The name ~x0 of the theorem ~
                          that rewrites the wrapper function ~x1 ~
                          in terms of the old function ~x2, ~
                          specified (perhaps by default) ~
                          by the :WRAPPER-TO-OLD-NAME input ~x3,"
                             name wrapper old wrapper-to-old-name))
           (error-msg? (fresh-namep-msg-weak name nil wrld))
           ((when error-msg?)
            (er-soft+ ctx t nil
                      "~@0 must be a valid fresh theorem name.  ~@1"
                      description error-msg?))
           ((er &) (ensure-not-member-of-list$
                    name
                    names-to-avoid
                    (msg "among the names ~x0 of other events ~
                      generated by this transformation"
                         names-to-avoid)
                    description
                    t
                    nil)))
        (value (list name (cons name names-to-avoid))))
    (if wrapper-to-old-name-present
        (er-soft+ ctx t nil
                  "Since the :WRAPPER input is (perhaps by default) NIL, ~
                   no :WRAPPER-TO-OLD-NAME input may be supplied,
                   but ~x0 was supplied instead."
                  wrapper-to-old-name)
      (value (list nil names-to-avoid)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define process-old-to-wrapper-enable (old-to-wrapper-enable
                                       (old-to-wrapper-enable-present booleanp)
                                       (gen-wrapper booleanp)
                                       ctx
                                       state)
  :returns (mv erp (old-to-wrapper booleanp) state)
  :short "Process the @(':old-to-wrapper-enable') input of
          an APT transformation."
  :long
  (xdoc::topstring-p
   "This is quite analogous to @(tsee process-old-to-new-enable),
    but for the @(':old-to-wrapper-enable') input of an APT transformation.
    The @('gen-wrapper') parameter is @('t') iff the wrapper is generated,
    i.e. if the @(':wrapper') input of the transformation is @('t').
    If this is @('nil'), we ensure that @(':old-to-wrapper-enable') is absent.")
  (if gen-wrapper
      (if old-to-wrapper-enable-present
          (b* (((er &)
                (ensure-value-is-boolean$ old-to-wrapper-enable
                                          "The :OLD-TO-WRAPPER-ENABLE input"
                                          t
                                          nil)))
            (value old-to-wrapper-enable))
        (value (get-default-input-old-to-wrapper-enable (w state))))
    (if old-to-wrapper-enable-present
        (er-soft+ ctx t nil
                  "Since the :WRAPPER input is (perhaps by default) NIL, ~
                   no :OLD-TO-WRAPPER-ENABLE input may be supplied,
                   but ~x0 was supplied instead."
                  old-to-wrapper-enable)
      (value nil)))
  :prepwork ((local (in-theory (enable acl2::ensure-value-is-boolean)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define process-wrapper-to-old-enable (wrapper-to-old-enable
                                       (wrapper-to-old-enable-present booleanp)
                                       (gen-wrapper booleanp)
                                       ctx
                                       state)
  :returns (mv erp (wrapper-to-old booleanp) state)
  :short "Process the @(':wrapper-to-old-enable') input of
          an APT transformation."
  :long
  (xdoc::topstring-p
   "This is quite analogous to @(tsee process-old-to-wrapper-name),
    but for the @(':wrapper-to-old-name') input of an APT transformation.")
  (if gen-wrapper
      (if wrapper-to-old-enable-present
          (b* (((er &)
                (ensure-value-is-boolean$ wrapper-to-old-enable
                                          "The :WRAPPER-TO-OLD-ENABLE input"
                                          t
                                          nil)))
            (value wrapper-to-old-enable))
        (value (get-default-input-wrapper-to-old-enable (w state))))
    (if wrapper-to-old-enable-present
        (er-soft+ ctx t nil
                  "Since the :WRAPPER input is (perhaps by default) NIL, ~
                   no :WRAPPER-TO-OLD-ENABLE input may be supplied,
                   but ~x0 was supplied instead."
                  wrapper-to-old-enable)
      (value nil)))
  :prepwork ((local (in-theory (enable acl2::ensure-value-is-boolean)))))
