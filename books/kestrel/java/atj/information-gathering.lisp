; Java Library
;
; Copyright (C) 2019 Kestrel Institute (http://www.kestrel.edu)
;
; License: A 3-clause BSD license. See the LICENSE file distributed with ACL2.
;
; Author: Alessandro Coglio (coglio@kestrel.edu)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package "JAVA")

(include-book "aij-notions")
(include-book "primitives")

(include-book "kestrel/std/system/pure-raw-p" :dir :system)
(include-book "kestrel/std/system/rawp" :dir :system)
(include-book "kestrel/utilities/er-soft-plus" :dir :system)
(include-book "kestrel/utilities/system/world-queries" :dir :system)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defxdoc+ atj-information-gathering
  :parents (atj-implementation)
  :short "Information gathering performed by @(tsee atj)."
  :long
  (xdoc::topstring
   (xdoc::p
    "This code gathers the following information:")
   (xdoc::ul
    (xdoc::li
     "The names of all the currently known ACL2 packages.
      These are used to initialize
      the Java representation of the ACL2 environment.")
    (xdoc::li
     "The names of all the ACL2 functions to be translated to Java,
      as determined by @('fn1'), ..., @('fnp')."))
   (xdoc::p
    "As we collect the ACL2 functions to be translated to Java,
     we also check that they satisfy the constraints
     stated in the user documentation.")
   (xdoc::p
    "The collection and checking of the ACL2 functions
     is realized via a worklist algorithm.
     The worklist is initialized with @('fn1'), ..., @('fnp').
     At each step, a function @('fn') is taken from the worklist and processed.
     If @('fn') satisfies all the necessary constraints,
     it is added to a list of collected functions (which is initially empty);
     otherwise, we stop with an error.
     If @('fn') is defined,
     we collect the functions in its defining body and add them to the worklist,
     except for those that are already in the worklist or in the collected list
     (so that we do not process the same function twice).
     Note that by adding @('fn') to the collected list
     before examining the functions in its defining body,
     we ensure termination in the presence of
     (singly or mutually) recursive functions.
     We proceed like this until the worklist is empty
     (unless we stop earlier with an error; see above).
     If there are no errors, at the end
     we will have checked all the functions
     transitively called by @('fn1'), ..., @('fnp'),
     and the collected list will contain all the functions
     that must be translated to Java.
     This is the basic algorithm, but there are some complications,
     described in the following.")
   (xdoc::p
    "A complication arises from
     calls of @(tsee return-last) whose first argument is @('\'acl2::mbe1-raw'),
     which are calls of @(tsee mbe) in translated form.
     As explained in the user documentation,
     when the @(':guards') input of ATJ is @('nil'),
     the Java code generated by ATJ executes ``in the logic'',
     and in particular executes the @(':logic') parts of @(tsee mbe)s;
     when instead the @(':guards') input of ATJ is @('t'),
     the Java code generated by ATJ assumes the satisfaction of the guards,
     and in particular executes the @(':exec') parts of @(tsee mbe)s.
     Thus, when we recursively collect the functions
     from the body of a defined function,
     when we encounter these calls of @(tsee return-last),
     we selectively descend into the @(':logic') or @(':exec') part
     (based on the value of the @(':guards') input),
     ignoring the other part.")
   (xdoc::p
    "Another complication arises from
     calls of @(tsee return-last) whose first argument is @('\'acl2::progn'),
     which are calls of @(tsee prog2$) and @(tsee progn$) in translated form.
     As explained in the documentation,
     code is generated from the last argument only,
     but the other arguments must be checked to satisfy constraints as well.
     Thus, we use two worklists and two collected lists:
     one worklist and one collected list for the functions
     for which Java code must be generated,
     and one worklist and one collected list for the functions
     that must be only checked to satisfy the constraints.
     At the end of the iteration,
     the first collected list is used to generate Java code,
     while the second collected list is discarded;
     however, this second collected list is used during the iteration,
     to keep track of the functions already checked
     that do not appear in the worklists or in the first collected list.
     The function @('fn') is always taken from the first worklist,
     unless this worklist is empty, in which case it is taken from the second:
     in other words, the first worklist is processed first,
     and then the second one;
     the iteration terminates when both worklists are empty.")
   (xdoc::p
    "Yet another complication arises from
     calls of functions in @(tsee *atj-primitive-fns*),
     which are translated directly to Java primitive literals and operations
     when @(':deep') is @('nil') and @(':guards') is @('t').
     Under these conditions, when @('fn') is taken from a worklist,
     it is added to the collected list and its defining body is not examined;
     i.e. it is treated like a natively implemented function,
     which it is in a sense.")
   (xdoc::p
    "As an optimization, ACL2 functions natively implemented in Java,
     as well as functions in @(tsee *atj-primitive-fns*)
     if @(':deep') is @('nil') and @(':guards') is @('t'),
     are never added to the worklists and collected lists.
     This is because they are known to satisfy the necessary constraints,
     and they are terminal nodes in the call graph being traversed.
     In fact, the worklist is initialized
     with possibly a subset of @('fn1'), ..., @('fnp'),
     obtained by removing any natively implemented functions
     (while the ones in @(tsee *atj-primitive-fns*),
     when @(':deep') is @('nil') and @(':guards') is @('t'),
     are already ruled out by input validation).
     When descending into the defining of a function,
     natively implemented functions,
     and functions in @(tsee *atj-primitive-fns*) when applicable,
     are skipped over, not checked against worlists and collected lists,
     and not added to any worklist.")
   (xdoc::p
    "Further details and complications of the worklist algorithm
     are explained in the implementing functions below."))
  :order-subtopics t
  :default-parent t)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defines atj-collect-fns-in-term
  :short "Collect all the functions in a term,
          in the course of the worklist algorithm."
  :long
  (xdoc::topstring
   (xdoc::p
    "See the "
    (xdoc::seetopic "atj-information-gathering" "overview")
    " of the worklist algorithm first.")
   (xdoc::p
    "This is called on the defining body
     of the function removed from the worklist,
     and recursively on subterms of the defining body.")
   (xdoc::p
    "Besides the term, this function takes as arguments
     the two worklists and the two collected lists:
     the @('-gen') suffix stands for `generation',
     i.e. the functions for which Java code must be generated;
     the @('-chk') suffix stands for `checking',
     i.e. the functions that must be just checked.
     The collected lists are only used to see
     which of the functions encountered in the term
     have already been processed by the worklist algorithm.
     The worklists are updated as appropriate,
     and eventually returned.")
   (xdoc::p
    "This function also takes an argument flag @('gen?') saying whether
     we are examining a term from (a function from) the first worklist
     or a term from a function from (a function from) the second worklist.")
   (xdoc::p
    "Since variables and quoted constants contain no functions,
     we return the worklists unchanged in these cases.")
   (xdoc::p
    "Note that a term @('(mbe :logic a :exec b)')
     is translated to @('(return-last \'acl2::mbe1-raw b a)').
     Thus, when @(':guards') is @('nil')
     we descend into the third argument of @(tsee return-last),
     while when @(':guards') is @('t')
     we descend into the second argument of @(tsee return-last).")
   (xdoc::p
    "Note that a term @('(prog2$ a b)')
     is translated to @('(return-last \'acl2::progn a b)')
     (and @(tsee progn$) is translated into a nest of @(tsee prog2$)s).
     Thus, when we encounter this kind of call,
     when we descend into the argument @('a')
     we set the @('gen?') flag to @('nil'),
     while when we descend into the argument @('b')
     we leave the @('gen?') flag unchanged.")
   (xdoc::p
    "If we encounter a call of @(tsee return-last) of some other form,
     we immediately return because such other forms are not supported.
     In this case, the third result of the function is set to @('t'),
     so that the caller can immediately recognize the situation
     and cause the iteration to terminate.")
   (xdoc::p
    "If we encounter a call of anything other than @(tsee return-last),
     we recursively process the arguments,
     propagating any error signaled by the third result.")
   (xdoc::p
    "If the call is of a lambda expression,
     we conclude by recursively processing
     the body of the lambda expression.")
   (xdoc::p
    "Otherwise, the call is of a named function (not @(tsee return-last)).
     If it is a natively implemented function,
     or in @(tsee *atj-primitive-fns*) when applicable,
     we do not add it to the worklist,
     because it satisfies all the necessary constraints
     and does not have a defining body to be inspected.
     Otherwise, we add the function to the appropriate worklist
     (the exact worklist is determined by the @('gen?') flag),
     unless it is already there or in a collected list.
     If @('gen?') is @('t') and the function is already
     in @('worklist-chk') or @('collected-chk')
     but not in @('worklist-gen') or @('collected-gen'),
     we need to add it to @('worklist-gen') nonetheless,
     because it must eventually end up in @('collected-gen')
     in order to generate code for it.
     Thus, if @('gen?') is @('t'),
     we only check it against @('worklist-gen') and @('collected-gen'),
     and if we add it to @('worklist-gen')
     we also remove it from @('worklist-chk') if present there
     (with @(tsee remove1) because worklists never have duplicates;
     if it is not present, no change to @('worklist-chk') occurs),
     so that the function is not processed again.
     We do not need to remove the function from @('collected-chk')
     because, when @('gen?') is @('t'), that collected list is always empty:
     the reason is that the iteration
     first processes @('worklist-gen') completely
     (during this processing @('gen?') is @('t')),
     keeping @('collected-chk') empty,
     and then it processes @('worklist-chk'),
     and it is during this processing (when @('gen?') is thus @('nil'))
     that @('collected-chk') gets populated."))
  :verify-guards nil

  (define atj-collect-fns-in-term ((term pseudo-termp)
                                   (gen? booleanp)
                                   (worklist-gen symbol-listp)
                                   (worklist-chk symbol-listp)
                                   (collected-gen symbol-listp)
                                   (collected-chk symbol-listp)
                                   (deep$ booleanp)
                                   (guards$ booleanp))
    :returns (mv (new-worklist-gen "A @(tsee symbol-listp).")
                 (new-worklist-chk "A @(tsee symbol-listp).")
                 (unsuppported-return-last? booleanp))
    (b* (((when (variablep term)) (mv worklist-gen worklist-chk nil))
         ((when (fquotep term)) (mv worklist-gen worklist-chk nil))
         (fn (ffn-symb term))
         ((when (eq fn 'return-last))
          (b* ((1st-arg (fargn term 1)))
            (case (unquote 1st-arg)
              (acl2::mbe1-raw (if guards$
                                  (atj-collect-fns-in-term (fargn term 2)
                                                           gen?
                                                           worklist-gen
                                                           worklist-chk
                                                           collected-gen
                                                           collected-chk
                                                           deep$
                                                           guards$)
                                (atj-collect-fns-in-term (fargn term 3)
                                                         gen?
                                                         worklist-gen
                                                         worklist-chk
                                                         collected-gen
                                                         collected-chk
                                                         deep$
                                                         guards$)))
              (acl2::progn (b* (((mv worklist-gen
                                     worklist-chk
                                     unsuppported-return-last?)
                                 (atj-collect-fns-in-term (fargn term 2)
                                                          nil
                                                          worklist-gen
                                                          worklist-chk
                                                          collected-gen
                                                          collected-chk
                                                          deep$
                                                          guards$))
                                ((when unsuppported-return-last?)
                                 (mv worklist-gen worklist-chk t)))
                             (atj-collect-fns-in-term (fargn term 3)
                                                      gen?
                                                      worklist-gen
                                                      worklist-chk
                                                      collected-gen
                                                      collected-chk
                                                      deep$
                                                      guards$)))
              (t (mv worklist-gen worklist-chk t)))))
         ((mv worklist-gen worklist-chk unsupported-return-last?)
          (atj-collect-fns-in-terms (fargs term)
                                    gen?
                                    worklist-gen
                                    worklist-chk
                                    collected-gen
                                    collected-chk
                                    deep$
                                    guards$))
         ((when unsupported-return-last?) (mv worklist-gen worklist-chk t))
         ((when (flambdap fn)) (atj-collect-fns-in-term (lambda-body fn)
                                                        gen?
                                                        worklist-gen
                                                        worklist-chk
                                                        collected-gen
                                                        collected-chk
                                                        deep$
                                                        guards$))
         ((when (atj-aij-nativep fn)) (mv worklist-gen worklist-chk nil))
         ((when (and (eq deep$ nil)
                     (eq guards$ t)
                     (member-eq fn *atj-primitive-fns*)))
          (mv worklist-gen worklist-chk nil)))
      (if gen?
          (if (or (member-eq fn worklist-gen)
                  (member-eq fn collected-gen))
              (mv worklist-gen worklist-chk nil)
            (mv (cons fn worklist-gen)
                (remove1-eq fn worklist-chk)
                nil))
        (if (or (member-eq fn worklist-gen)
                (member-eq fn worklist-chk)
                (member-eq fn collected-gen)
                (member-eq fn collected-chk))
            (mv worklist-gen worklist-chk nil)
          (mv worklist-gen
              (cons fn worklist-chk)
              nil)))))

  (define atj-collect-fns-in-terms ((terms pseudo-term-listp)
                                    (gen? booleanp)
                                    (worklist-gen symbol-listp)
                                    (worklist-chk symbol-listp)
                                    (collected-gen symbol-listp)
                                    (collected-chk symbol-listp)
                                    (deep$ booleanp)
                                    (guards$ booleanp))
    :returns (mv (new-worklist-gen "A @(tsee symbol-listp).")
                 (new-worklist-chk "A @(tsee symbol-listp).")
                 (unsuppported-return-last? booleanp))
    (b* (((when (endp terms)) (mv worklist-gen worklist-chk nil))
         ((mv worklist-gen worklist-chk unsuppported-return-last?)
          (atj-collect-fns-in-term (car terms)
                                   gen?
                                   worklist-gen
                                   worklist-chk
                                   collected-gen
                                   collected-chk
                                   deep$
                                   guards$))
         ((when unsuppported-return-last?) (mv worklist-gen worklist-chk t)))
      (atj-collect-fns-in-terms (cdr terms)
                                gen?
                                worklist-gen
                                worklist-chk
                                collected-gen
                                collected-chk
                                deep$
                                guards$))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define atj-worklist-iterate ((worklist-gen symbol-listp)
                              (worklist-chk symbol-listp)
                              (collected-gen symbol-listp)
                              (collected-chk symbol-listp)
                              (deep$ booleanp)
                              (guards$ booleanp)
                              (verbose$ booleanp)
                              ctx
                              state)
  :returns (mv erp
               (fns "A @(tsee symbolp).")
               state)
  :mode :program
  :short "Worklist algorithm iteration."
  :long
  (xdoc::topstring
   (xdoc::p
    "See the "
    (xdoc::seetopic "atj-information-gathering" "overview")
    " of the worklist algorithm first.")
   (xdoc::p
    "The iteration ends when both worklists are empty.
     When that happens, we return the collected list of functions
     for which code must be generated.")
   (xdoc::p
    "We always pick the next function from @('worklist-gen'),
     until it is empty; then we switch to @('worklist-chk').
     Since we start with all empty lists except @('worklist-gen')
     (see the caller of this function),
     as we go through @('worklist-gen') we may populate
     @('collected-gen') and @('worklist-chk'),
     but not @('collected-chk').
     When we go through @('worklist-chk'),
     we may further populate @('collected-chk'),
     but not @('worklist-gen') or @('collected-gen').")
   (xdoc::codeblock
    "Initial lists:"
    "  (...) () () ()"
    "After processing the first worklist:"
    "  () (...) (...) ()"
    "After processing the second worklist:"
    "  () () (...) (...)")
   (xdoc::p
    "The iteration terminates because
     there is a finite number of functions in the ACL2 world,
     but for simplicity we leave this function in program mode
     to avoid having to articulate the termination proof.")
   (xdoc::p
    "Note that, as explained in the overview of the algorithm,
     functions natively implemented, which include the ACL2 primitive functions,
     never appear in the worklists and collected lists.
     Thus, when we encounter a function without an unnormalized body,
     we stop with an error.")
   (xdoc::p
    "If the function satisfies all the needed constraints,
     its name is printed in verbose mode.
     The caller of this function precedes this printing
     with a suitable message (see the caller).")
   (xdoc::p
    "It should be an invariant that there are no duplicate function symbols
     in the four lists (worklists and collected lists) altogether;
     i.e. each list is free of duplicates,
     and the lists are pairwise disjoint.")
   (xdoc::p
    "Note that since @(tsee atj-collect-fns-in-term)
     extends the worklists via @(tsee cons),
     and since the fixpoint iteration picks the next function via @(tsee car),
     we visit the call graph depth-first;
     the worklists are used as stacks."))
  (b* (((when (and (endp worklist-gen)
                   (endp worklist-chk))) (value collected-gen))
       ((mv fn
            gen?
            worklist-gen
            worklist-chk) (if (consp worklist-gen)
                              (mv (car worklist-gen)
                                  t
                                  (cdr worklist-gen)
                                  worklist-chk)
                            (mv (car worklist-chk)
                                nil
                                worklist-gen
                                (cdr worklist-chk))))
       ((when (and (rawp fn state)
                   (not (pure-raw-p fn))))
        (er-soft+ ctx t nil
                  "The function ~x0 has raw Lisp code ~
                   and is not in the whitelist; ~
                   therefore, code generation cannot proceed." fn))
       ((unless (no-stobjs-p fn (w state)))
        (er-soft+ ctx t nil
                  "The function ~x0 has input or output stobjs; ~
                   therefore, code generation cannot proceed." fn))
       (body (getpropc fn 'unnormalized-body))
       ((unless body)
        (er-soft+ ctx t nil
                  "The function ~x0 has no unnormalized body; ~
                   therefore, code generation cannot proceed." fn))
       ((run-when verbose$)
        (cw "  ~x0~%" fn))
       ((mv collected-gen
            collected-chk) (if gen?
                               (mv (cons fn collected-gen)
                                   collected-chk)
                             (mv collected-gen
                                 (cons fn collected-chk))))
       ((mv worklist-gen worklist-chk unsuppported-return-last?)
        (atj-collect-fns-in-term body
                                 gen?
                                 worklist-gen
                                 worklist-chk
                                 collected-gen
                                 collected-chk
                                 deep$
                                 guards$))
       ((when unsuppported-return-last?)
        (er-soft+ ctx t nil
                  "The function RETURN-LAST is used ~
                   with an unsupported first argument; ~
                   therefore, code generation cannot proceed.")))
    (atj-worklist-iterate worklist-gen
                          worklist-chk
                          collected-gen
                          collected-chk
                          deep$
                          guards$
                          verbose$
                          ctx state)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define atj-fns-to-translate ((targets$ symbol-listp)
                              (deep$ booleanp)
                              (guards$ booleanp)
                              (verbose$ booleanp)
                              ctx
                              state)
  :returns (mv erp
               (fns "A @(tsee symbol-listp).")
               state)
  :mode :program
  :short "Collect the names of all the ACL2 functions to be translated to Java,
          checking that they satisfy all the necessary constraints."
  :long
  (xdoc::topstring
   (xdoc::p
    "See the "
    (xdoc::seetopic "atj-information-gathering" "overview")
    " of the worklist algorithm first.")
   (xdoc::p
    "We start the worklist iteration with the targets supplied by the user,
     minus any natively implemented function,
     as discussed in the overview.
     Currently the natively implemented functions
     are exactly the ACL2 primitive functions.")
   (xdoc::p
    "The returned list of function names should have no duplicates,
     but we double-check that for robustness.
     The list is in no particular order."))
  (b* (((run-when verbose$)
        (cw "~%ACL2 functions to translate to Java:~%"))
       (worklist-gen (set-difference-eq
                      targets$
                      (strip-cars *primitive-formals-and-guards*)))
       ((er fns) (atj-worklist-iterate worklist-gen
                                       nil
                                       nil
                                       nil
                                       deep$
                                       guards$
                                       verbose$
                                       ctx
                                       state))
       ((unless (no-duplicatesp-eq fns))
        (value (raise "Internal error: ~
                       the list ~x0 of collected function names ~
                       has duplicates."
                      fns))))
    (value fns)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define atj-gather-info ((targets$ symbol-listp)
                         (deep$ booleanp)
                         (guards$ booleanp)
                         (verbose$ booleanp)
                         ctx
                         state)
  :returns (mv erp
               (result "A tuple @('(pkgs
                                    fns-to-translate)')
                        satisfying
                        @('(typed-tuplep string-listp
                                         symbol-listp
                                         result)'),
                        where @('pkgs') is the list of names of
                        all known packages in chronological order,
                        and @('fns-to-translate') are
                        the functions to translate to Java.")
               state)
  :mode :program
  :short "Gather the information about the ACL2 environment
          needed to generate Java code."
  (b* ((pkgs (known-packages state))
       ((run-when verbose$)
        (cw "~%Known ACL2 packages:~%")
        (atj-show-pkgs pkgs))
       ((er fns-to-translate)
        (atj-fns-to-translate targets$ deep$ guards$ verbose$ ctx state)))
    (value (list pkgs fns-to-translate)))

  :prepwork
  ((define atj-show-pkgs ((pkgs string-listp))
     :returns (nothing null)
     :parents nil
     (if (endp pkgs)
         nil
       (b* ((- (cw "  ~s0~%" (car pkgs))))
         (atj-show-pkgs (cdr pkgs)))))))
