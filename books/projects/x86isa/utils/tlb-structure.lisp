(in-package "X86ISA")

(include-book "basic-structs")
(local (include-book "centaur/bitops/ihsext-basics" :dir :system))
(include-book "centaur/fty/bitstruct" :dir :system)

(defbitstruct tlb-key
              ((wp bitp)
               (smep bitp)
               (smap bitp)
               (ac bitp)
               (nxe bitp)
               (r-w-x 2bits)
               (cpl 2bits)
               (vpn 36bits))
              :inline t)

;; The make-tlb function generated by defbitstruct is incredibly slow because
;; it uses logapp and logapp isn't declared inline. We define logapp-inline,
;; which we define as a macro since ccl won't inline it if we define it as an
;; inline function and then use it to create tlb-key-fast which is defined
;; logically as tlb-key but in execution uses logapp-inline. We then define
;; make-tlb-key-fast, which is the same as make-tlb-key, but uses tlb-key-fast
;; internally instead of tlb-key.

(defmacro logapp-inline
  (n a b)
  `(logior (logand ,a (1- (ash 1 ,n)))
           (ash ,b ,n)))

(local
  (defthmd logapp-is-logapp-inline
           (implies (and (natp n)
                         (integerp a)
                         (integerp b))
                    (equal (logapp n a b)
                           (logapp-inline n a b)))
           :hints (("Goal" :in-theory (enable bitops::logapp** bitops::logapp-induct)))))

(local
  (define gen-fast-ctor (fields)
    :mode :program
    (b* (((list* field rst) fields)
         ((fty::bitstruct-field field))
         ((mv width body)
          (if (null rst)
            (mv field.width field.name)
            (b* (((mv rst-width rst-body) (gen-fast-ctor rst)))
                (mv (+ rst-width field.width)
                    `(logapp-inline ,field.width ,field.name
                                              ,rst-body))))))
        (mv width `(the (unsigned-byte ,width)
                        ,body)))))

(local
  (define gen-fast-ctor-arg-list (fields)
    :mode :program
    (b* (((when (null fields)) nil)
         ((list* field rst) fields)
         ((fty::bitstruct-field field)))
        (cons `(,field.name :type (unsigned-byte ,field.width))
              (gen-fast-ctor-arg-list rst)))))

(make-event
  (b* ((bitstruct-table (table-alist 'fty::bitstruct-table (w state)))
       (tlb-key-structure (fty::lookup-bitstruct 'tlb-key bitstruct-table))
       ((fty::bitstruct tlb-key-structure))
       (tlb-key-formals (acl2::formals 'tlb-key (w state)))
       ((mv & ctor-body) (gen-fast-ctor tlb-key-structure.fields)))
      `(progn
         (define tlb-key-fast 
          ,(gen-fast-ctor-arg-list tlb-key-structure.fields)
          :enabled t
          :guard-hints (("Goal" :in-theory (enable tlb-key logapp-is-logapp-inline)))
          (mbe :logic (tlb-key ,@tlb-key-formals)
               :exec ,ctor-body))
         ,(std::da-make-maker 'tlb-key-fast
                              (fty::bitstruct-primary-fields->names tlb-key-structure.fields)
                              (fty::bitstruct-fields->defaults tlb-key-structure.fields)))))

(define good-tlb-key-p (key)
  :enabled t
  :guard t
  (and (tlb-key-p key)
       (<= (tlb-key->r-w-x key) 2)))

(define good-tlb-key-fix (key)
  :guard (good-tlb-key-p key)
  :inline t
  (mbe :logic (if (good-tlb-key-p key)
                key
                0)
       :exec key)
  ///
  (defthm good-tlb-key-fix-is-identity-on-good-tlb-key-p
          (implies (good-tlb-key-p x)
                   (equal (good-tlb-key-fix x)
                          x)))

  (defthm good-tlb-key-fix-is-good-tlb-key
          (good-tlb-key-p (good-tlb-key-fix x))))

(fty::deffixtype good-tlb-key
                 :pred good-tlb-key-p
                 :fix good-tlb-key-fix
                 :equiv good-tlb-key-equiv
                 :define t
                 :forward t)

(define tlb-entryp (x)
  :guard t
  :enabled t
  (b* (((unless (consp x)) nil)
       ((cons key val) x))
      (and  (good-tlb-key-p key)
            (unsigned-byte-p (- #.*physical-address-size* 12) val))))

(define tlbp (tlb)
  :guard t
  (b* (((unless (consp tlb)) (equal tlb :tlb))
       ((list* el tail) tlb)
       ((unless (tlb-entryp el)) nil))
      (tlbp tail))
  ///
  (defthm |:tlb-is-tlbp|
          (tlbp :tlb))

  (defthm consing-tlb-entry-onto-tlbp-is-tlbp
          (implies (and (tlb-entryp entry)
                        (tlbp tlb))
                   (tlbp (cons entry tlb))))

  (defthm integerp-cdr-hons-assoc-equal-tlb
          (implies (tlbp tlb)
                   (b* ((result (hons-assoc-equal key tlb)))
                       (implies result
                                (integerp (cdr result)))))
          :hints (("Goal" :in-theory (enable (hons-assoc-equal)))))

  (defthm unsigned-byte-p-40-cdr-hons-assoc-equal-tlb
          (implies (tlbp tlb)
                   (b* ((result (hons-assoc-equal key tlb)))
                       (implies result
                                (unsigned-byte-p (- #.*physical-address-size* 12) (cdr result)))))
          :hints (("Goal" :in-theory (enable (hons-assoc-equal))))))

(define tlb-fix (x)
  :guard t
  :returns (tlb tlbp)
  (if (tlbp x)
    x
    :tlb)
  ///
  (defthm tlb-fix-of-tlb
          (implies (tlbp x)
                   (equal (tlb-fix x) x))))
