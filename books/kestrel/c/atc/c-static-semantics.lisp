; C Library
;
; Copyright (C) 2020 Kestrel Institute (http://www.kestrel.edu)
;
; License: A 3-clause BSD license. See the LICENSE file distributed with ACL2.
;
; Author: Alessandro Coglio (coglio@kestrel.edu)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package "C")

(include-book "c-abstract-syntax")
(include-book "portable-ascii-identifiers")

(include-book "kestrel/fty/sbyte32" :dir :system)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defxdoc+ atc-c-static-semantics
  :parents (atc)
  :short "A static semantics of C for ATC."
  :long
  (xdoc::topstring
   (xdoc::p
    "In order to support the generation of proofs for
     the C code generated by ATC,
     we need a static semantics (as well as a dynamic semantics)
     of (the needed portion of) C.
     The static semantics serves to prove that
     the generated C code compiles.
     Here we provide an initial formal static semantics,
     which should support the generation of proofs
     for an initial version of ATC.")
   (xdoc::p
    "This preliminary static semantics may be extended in the future,
     and may be replaced by a more comprehensive model
     that we will be developing as part of the "
    (xdoc::seetopic "language" "language formalization")
    ".")
   (xdoc::p
    "The static semantics is defined over the C abstract syntax,
     but for now it rejects many valid constructs
     just because ATC does not generate those constructs for now.
     This way, we keep the static semantics clearer.
     Being too restrictive is adequate here:
     if a program generated by ATC passes the constraints
     of this excessively strict static semantics,
     it is a valid C program,
     regardless of the fact that many valid C programs (not generated by ATC)
     are rejected by this static semantics.")
   (xdoc::p
    "This static semantics uses the notion of `well-formed'
     to describe abstract syntactic entities
     that satisfy the constraints of the static semantics."))
  :order-subtopics t
  :default-parent t)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define ident-wfp ((id identp))
  :returns (yes/no booleanp)
  :short "Check if an identifier is well-formed."
  :long
  (xdoc::topstring
   (xdoc::p
    "We check whether the underlying ACL2 string satisfies the conditions
     described in Section `C identifiers' of @(tsee atc).
     As noted there, C18 allows a possibly broader range of valid identifiers,
     but ATC only generates this kind of portable identifiers."))
  (atc-ident-stringp (ident->get id))
  :hooks (:fix))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define iconst-wfp ((ic iconstp))
  :returns (yes/no booleanp)
  :short "Check if an integer constant is well-formed."
  :long
  (xdoc::topstring
   (xdoc::p
    "For now we require the integer constant
     to be decimal (not octal or hexadecimal),
     to be signed,
     and to have no type suffixes.
     This means that the integer constant must have type @('int'),
     and therefore that its numberic value must in that type's range.
     Given our current definition of @(tsee sintp),
     the value must fit in 32 bits (with the sign bit being 0)."))
  (b* (((iconst ic) ic))
    (and (acl2::sbyte32p ic.value)
         (equal ic.base (iconst-base-dec))
         (not ic.unsignedp)
         (equal ic.type (iconst-tysuffix-none))))
  :hooks (:fix))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define const-wfp ((c constp))
  :returns (yes/no booleanp)
  :short "Check if a constant is well-formed."
  :long
  (xdoc::topstring
   (xdoc::p
    "For now we only accept well-formed integer constants.
     The other kinds of constants are placeholders in our abstract syntax,
     anyhow."))
  (const-case c
              :int (iconst-wfp c.get)
              :float nil
              :enum nil
              :char nil)
  :hooks (:fix))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define unop-wfp ((op unopp))
  :returns (yes/no booleanp)
  :short "Check if a unary operator is well-formed."
  :long
  (xdoc::topstring
   (xdoc::p
    "In C they are all well-formed of course,
     but for now we only allow unary plus and minus."))
  (and (member-eq (unop-kind op) '(:plus :minus)) t)
  :hooks (:fix))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define binop-wfp ((op binopp))
  :returns (yes/no booleanp)
  :short "Check if a binary operator is well-formed."
  :long
  (xdoc::topstring
   (xdoc::p
    "In C they are all well-formed of course,
     but for now we only allow
     addition, subtraction, multiplication, division, and remainder."))
  (and (member-eq (binop-kind op) '(:add :sub :mul :div :rem)) t)
  :hooks (:fix))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define tyspecseq-wfp ((tss tyspecseqp))
  :returns (yes/no booleanp)
  :short "Check if a sequence of type specifiers is well-formed."
  :long
  (xdoc::topstring
   (xdoc::p
    "In C they are all well-formed of course,
     but for now we only allow the one for @('int')."))
  (tyspecseq-case tss :sint)
  :hooks (:fix))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define tyname-wfp ((tn tynamep))
  :returns (yes/no booleanp)
  :short "Check if a type name is well-formed."
  :long
  (xdoc::topstring
   (xdoc::p
    "We check that the underlying sequence of type specifiers is well-formed."))
  (tyspecseq-wfp (tyname->specs tn))
  :hooks (:fix))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defines expr-wfp
  :short "Check if an expression is well-formed."
  :long
  (xdoc::topstring
   (xdoc::p
    "For now we only allow
     (well-formed) identifiers,
     (well-formed) constants,
     unary expressions with well-formed operators and operands,
     and binary expressions with well-formed operators and operands.
     We disallow
     function calls,
     pre/post-increment/decrement,
     casts,
     and ternary (i.e. conditional) expressions.")
   (xdoc::p
    "Normally a static semantics would also return a type for each expression,
     but for now all our expressions have type @('int'),
     so there is no need to return this."))

  (define expr-wfp ((e exprp))
    :returns (yes/no booleanp)
    (expr-case e
               :ident (ident-wfp e.get)
               :const (const-wfp e.get)
               :call nil
               :postinc nil
               :postdec nil
               :preinc nil
               :predec nil
               :unary (and (unop-wfp e.op)
                           (expr-wfp e.arg))
               :cast nil
               :binary (and (binop-wfp e.op)
                            (expr-wfp e.arg1)
                            (expr-wfp e.arg2))
               :cond nil)
    :measure (expr-count e))

  (define expr-list-wfp ((es expr-listp))
    :returns (yes/no booleanp)
    (or (endp es)
        (and (expr-wfp (car es))
             (expr-list-wfp (cdr es))))
    :measure (expr-list-count es))

  ///

  (fty::deffixequiv-mutual expr-wfp))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define stmt-wfp ((s stmtp))
  :short "Check if a statement is well-formed."
  :long
  (xdoc::topstring
   (xdoc::p
    "For now we only allow
     @('return') statements with (well-formed) expressions."))
  (stmt-case s
             :labeled nil
             :compound nil
             :expr nil
             :null nil
             :if nil
             :ifelse nil
             :switch nil
             :while nil
             :dowhile nil
             :for nil
             :goto nil
             :continue nil
             :break nil
             :return (and s.value
                          (expr-wfp s.value)))
  :hooks (:fix))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define param-decl-wfp ((param param-declp))
  :returns (yes/no booleanp)
  :short "Check if a parameter declaration is well-formed."
  :long
  (xdoc::topstring
   (xdoc::p
    "We require its components to be well-formed."))
  (b* (((param-decl param) param))
    (and (tyspecseq-wfp param.type)
         (ident-wfp param.name)))
  :hooks (:fix))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define param-decl-list-wfp ((params param-decl-listp))
  :returns (yes/no booleanp)
  :short "Check if a list of parameter declarations is well-formed."
  :long
  (xdoc::topstring
   (xdoc::p
    "Not only each parameter declaration must be well-formed,
     but also the names must be all distinct."))
  (and (param-decl-list-wfp-aux params)
       (no-duplicatesp-equal (param-decl-list->name-list params)))
  :hooks (:fix)

  :prepwork
  ((std::deflist param-decl-list-wfp-aux (x)
     (param-decl-wfp x)
     :guard (param-decl-listp x)
     :elementp-of-nil nil
     ///
     (fty::deffixequiv param-decl-list-wfp-aux
       :args ((x param-decl-listp))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define fundef-wfp ((fundef fundefp))
  :returns (yes/no booleanp)
  :short "Check if a function definition is well-formed."
  :long
  (xdoc::topstring
   (xdoc::p
    "Its components must be well-formed."))
  (b* (((fundef fundef) fundef))
    (and (tyspecseq-wfp fundef.result)
         (ident-wfp fundef.name)
         (param-decl-list-wfp fundef.params)
         (stmt-wfp fundef.body)))
  :hooks (:fix))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define ext-decl-wfp ((ext ext-declp))
  :returns (yes/no booleanp)
  :short "Check if an external declaration is well-formed."
  :long
  (xdoc::topstring
   (xdoc::p
    "For now we only allow well-formed function definitions."))
  (ext-decl-case ext
                 :fundef (fundef-wfp ext.get)
                 :decl nil)
  :hooks (:fix))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(std::deflist ext-decl-list-wfp (x)
  (ext-decl-wfp x)
  :guard (ext-decl-listp x)
  :short "Lift @(tsee ext-decl-wfp) to lists."
  :elementp-of-nil nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define transunit-wfp ((tunit transunitp))
  :returns (yes/no booleanp)
  :short "Check if a translation unit is well-formed."
  :long
  (xdoc::topstring
   (xdoc::p
    "Not only each external declaration must be well-formed,
     but also the names of the functions must be all distinct."))
  (b* (((transunit tunit) tunit))
    (and (ext-decl-list-wfp tunit.decls)
         (no-duplicatesp-equal
          (fundef-list->name-list
           (ext-decl-list->fundef-list
            tunit.decls)))))
  :hooks (:fix))
