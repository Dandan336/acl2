; Copyright (C) 2016, Regents of the University of Texas
; Written by Matt Kaufmann
; License: A 3-clause BSD license.  See the LICENSE file distributed with ACL2.

(in-package "ACL2")

; To do:

; - Document verify-guards-program with xdoc.

; - Control the output, perhaps simply by turning it off unless a :verbose
;   option is supplied.  Notice for example the error message currently
;   produced for f5p in the example (verify-guards-program f6p) below.

; - For each system utility used below, either document it in :doc
;   system-utilities or replace it below with a corresponding documented system
;   utility.

; - Perhaps store functions in a table when they are "guard-verified" in this
;   sense, and insist that all supporters (ancestors) are in that table before
;   applying verify-guards-program to a given function symbol.  The table could
;   probably be easily extended by having the top-level make-event generate a
;   table event.

; - Consider causing an error if the argument to verify-guards-program is
;   already a guard-verified function symbol, and maybe even if it's already in
;   :logic mode (since then perhaps verify-guards would be more appropriate).

; - Consider a mechanism for providing hints.

; - Consider adding an option that proves both termination and guards for the
;   given function, rather than skipping the termination proof.

; - Consider including the book misc/eval.lisp and use must-fail and perhaps
;   must-succeed to incorporate the tests at the end, below.  Perhaps the
;   successes could simply be local encapsulates.  Maybe create
;   verify-guards-program-tests.lisp for this.  Maybe add bigger tests.

; - It seems likely that we will need to deal with the following problem.
;   Suppose that a :program mode function is defined using some raw Lisp code.
;   Then we will not be able to promote that function to :logic mode; see the
;   test involving 'program-fns-with-raw-code in function
;   redefinition-renewal-mode, or just try (verify-termination ev) after
;   (set-state-ok t).  A reasonably straightforward solution is as follows: for
;   any non-built-in function f that has such a supporter (like ev), even if
;   not an immediate supporter, redefine f using defstub instead of using
;   verify-termination and verify-guards.  The LD form generated by
;   verify-guards-program could include keyword option :ld-redefinition-action
;   with value '(:warn! . :overwrite), as in :redef!.  BUT oops, we don't want
;   to redefined functions like ev!  So maybe use FLET above where they're
;   called.  NOTE: Matt has tentative solution using new state global
;   'verify-termination-program-with-raw-code.

; - Deal with the comment in verify-termination-forms-with-measures.  Better
;   yet: avoid the :OR by checking for measures and then always laying down the
;   :? "call" when there's no measure.

; - Consider an option for whether or not to skip-proofs on the
;   verify-termination for the top-level function.

; - Have an option that just returns the forms, rather than passing them to LD.

; - Consider returning an error rather than (value :FAILED) when
;   verify-guards-program fails.

; - Perhaps remove excess skip-proofs.

; - Note that because a defttag is executed under the make-event, a command
;   tuple is laid down when using verify-guards-program if no previous defttag
;   has been executed.  Often that defttag won't be needed, so consider adding
;   a keyword argument to control whether or not the defttag is done.  Or
;   perhaps even compute whether it's needed, say by seeing whether system
;   functions are involved.  Perhaps we shouldn't even be messing with system
;   functions at all; see the discussion pertaining to FLET, above.

(program)

(defun all-ffn-symbs-lst+translate (forms fns ctx wrld state-vars acc)

; We are translating only to get the function symbols, so we don't concern
; ourselves about translating for execution.

  (cond
   ((endp forms) acc)
   (t (all-ffn-symbs-lst+translate
       (cdr forms)
       (cdr fns)
       ctx wrld state-vars
       (mv-let (erp tbody)
         (translate-cmp (car forms)
                        t   ; stobjs-out
                        nil ; logic-modep
                        t   ; known-stobjs
                        ctx wrld state-vars)
         (cond
          (erp (er hard ctx
                   "Surprise: Translate failed for body of ~x0!"
                   (car fns)))
          (t (all-ffn-symbs tbody
                            (all-ffn-symbs (guard (car fns) nil wrld)
                                           acc)))))))))

(defun all-ffn-symbs-mut-rec-logic (names wrld acc)
  (cond ((endp names) acc)
        (t (all-ffn-symbs-mut-rec-logic
            (cdr names)
            wrld
            (all-ffn-symbs (body (car names) nil wrld)
                           (all-ffn-symbs (guard (car names) nil wrld)
                                          acc))))))

(defun immediate-supps (fn old-fns wrld ctx state-vars)
  (cond
   ((eq (getpropc fn 'symbol-class nil wrld)
        :ideal)
    (let ((recp (getpropc fn 'recursivep nil wrld)))
      (cond ((cdr recp)
             (mv recp (all-ffn-symbs-mut-rec-logic recp wrld old-fns)))
            (t
             (mv nil (all-ffn-symbs (body fn nil wrld)
                                    (all-ffn-symbs (guard fn nil wrld)
                                                   old-fns)))))))
   (t (let* ((defs (recover-defs-lst fn wrld))
             (sibs (strip-cars defs)))
        (mv sibs
            (all-ffn-symbs-lst+translate (strip-last-elements defs)
                                         sibs
                                         ctx wrld state-vars old-fns))))))

(defun hons-acons-nil-lst (lst alist)
  (cond ((endp lst) alist)
        (t (hons-acons-nil-lst (cdr lst)
                               (hons-acons (car lst) nil alist)))))

(defun non-compliant-supporters-rec (fns wrld ctx state-vars supps)

; At the top level, where supps is an atom, we extend supps by associating each
; supporter of a function fn in fns with one of the following.

; t    - normal case, where fn is not defined recursively
; sibs - a list of all mutual-recursion siblings of fn, including fn (in
;        the singly-recursive case, including only fn)
; nil  - fn is defined in a mutual-recursion with some g already associated
;        with a non-nil value in supps

; As we recur, we skip any member of fns that is already a key of supps.

  (cond
   ((endp fns) supps)
   ((or (eq (getpropc (car fns) 'symbol-class nil wrld)
            :common-lisp-compliant)
        (hons-get (car fns) supps))
    (non-compliant-supporters-rec (cdr fns) wrld ctx state-vars supps))
   (t (mv-let (sibs extended-fns)
        (immediate-supps (car fns) (cdr fns) wrld ctx state-vars)
        (non-compliant-supporters-rec
         extended-fns wrld ctx state-vars
         (hons-acons (car fns)
                     (or sibs t)
                     (hons-acons-nil-lst sibs supps)))))))

(defun non-compliant-supporters-fixer (alist acc)

; For each (fn . val) in the alist computed by non-compliant-supporters-rec,
; val is one of three forms documented there: a list sibs in the recursive
; case, t in the non-recursive case, and nil for entries to be skipped.  Here
; we drop the nil entries (and reverse the order, but that's irrelevant).  We
; also drop the final cdr.

  (cond ((atom alist) acc)
        (t (non-compliant-supporters-fixer
            (cdr alist)
            (if (null (cdar alist))
                acc
              (cons (car alist) acc))))))

(defun non-compliant-supporters (fn wrld)

; We return an alist associating each function symbol ancestral in fn that is
; not :common-lisp-compliant with nil if the symbol is not mutually recursive,
; else with the list of all its mutual-recursion siblings.

  (with-fast-alist 'supps
    (non-compliant-supporters-fixer
     (non-compliant-supporters-rec (list fn)
                                   wrld
                                   'non-compliant-supporters
                                   (default-state-vars nil
                                     :temp-touchable-vars t
                                     :temp-touchable-fns t)
                                   'supps)
     nil)))

(defun order-alist-by-absolute-event-number (alist wrld acc)

; They keys of the given alist are all function symbols of wrld.  We return a
; new alist with the same entries, but ordered by absolute event number of the
; key, so that the first entry is for the first function symbol introduced and
; the last entry is for the last function symbol introduced.

  (cond ((endp alist)
         (strip-cdrs (merge-sort-car-< acc)))
        (t (order-alist-by-absolute-event-number
            (cdr alist)
            wrld
            (acons (getpropc (caar alist) 'absolute-event-number nil wrld)
                   (car alist)
                   acc)))))

(defun verify-termination-forms-with-measures (fns wrld)
  (cond ((endp fns) nil)
        (t (cons

; If there is already a measure declared for (car fns), it will be an error to
; lay down a measure here.  However, if there is a measure declared for (car
; fns) then it seems unlikely we would need to call
; verify-termination-forms-mut-rec, since presumably the other siblings have
; measures too and thus verify-termination-form would succeed without needing
; to do this computation.  Still, an error is possible.

            `(,(car fns)
              (declare (xargs :measure
                              (:? ,@(formals (car fns) wrld))
                              :verify-guards nil)))
            (verify-termination-forms-with-measures (cdr fns) wrld)))))

(defun verify-termination-form (f sibs wrld)
  (cond ((consp sibs) ; recursive

; Initially, the test above was (getpropc f 'recursivep nil wrld).  But that's
; only a suitable test if f is in :logic mode.  The point here is that for
; recursive functions, ACL2 might not be able to guess a measure when no
; measure is supplied, so the first verify-termination form below might fail;
; see f5p below for an example.  Our solution to that problem is simply to try
; again in that case, supplying an explicit measure arbitrarily based on the
; first formal.  (If the formals are nil this might or might not work, but the
; formals are very unlikely to be nil for a recursively defined function.)

         `(make-event
           '(:or (skip-proofs
                  (verify-termination ,f
                    (declare (xargs :verify-guards nil))))
                 (skip-proofs
                  (verify-termination
                    ,@(verify-termination-forms-with-measures sibs wrld))))))
        (t `(skip-proofs (verify-termination ,f
                           (declare (xargs :verify-guards nil)))))))

(defun verify-term-guards-form (g sibs wrld)
  (cond ((eq (getpropc g 'symbol-class nil wrld)
             :program)
         `(progn
            ,(verify-termination-form g sibs wrld)
            (verify-guards ,g)))
        (t ; typically (eq class :ideal)
         `(verify-guards ,g))))

(defun verify-guards-program-forms-1 (fn-alist wrld acc)

; Fn-alist is an alist with entries (fn . val), where fn is a function symbol
; of wrld and val is t if fn is non-recursive, else val is a list of the
; mutual-recursion siblings of fn (hence, just (fn) if fn is singly recursive).
; Moreover, fn-alist is sorted by absolute-event-number: the key that is the
; oldest function symbol comes first, and newest, last.

  (cond ((atom fn-alist)
         (reverse acc)) ; restore the order
        (t (verify-guards-program-forms-1
            (cdr fn-alist)
            wrld
            (let ((entry (car fn-alist)))
              (cons (let ((form (verify-term-guards-form (car entry)
                                                         (cdr entry)
                                                         wrld)))
                      (if (consp (cdr fn-alist))
                          `(skip-proofs ,form)
                        form))
                    acc))))))

(defun verify-guards-program-forms (fn wrld)
  (cond ((not (and (symbolp fn)
                   (function-symbolp fn wrld)))
         `((value-triple (er hard 'verify-guards-program
                             "Not a function symbol: ~x0"
                             ',fn))))
        (t (let* ((alist (order-alist-by-absolute-event-number
                          (non-compliant-supporters fn wrld)
                          wrld
                          nil)))
             (verify-guards-program-forms-1 alist wrld nil)))))

(defmacro verify-guards-program (fn &key
                                    (print ':use-default print-p))
  `(make-event (mv-let (erp val state)
                 (ld (list* '(logic)
                            '(set-state-ok t)
                            '(set-irrelevant-formals-ok t)
                            '(set-ignore-ok t)
                            '(defttag t)
                            '(set-temp-touchable-vars t state)
                            '(set-temp-touchable-fns t state)
                            (verify-guards-program-forms ',fn (w state)))
                     :ld-error-action :error
                     ,@(and print-p `(:ld-pre-eval-print ,print)))
                 (declare (ignore val))
                 (value (list 'value-triple
                              (if erp :FAILED :SUCCESS))))))

; Examples:
#||

(logic)

(progn
  (defun f1p (x) (declare (xargs :mode :program)) x)
  (defun f2p (x)
    (declare (xargs :mode :program))
    (if (consp x) (f2p (cdr x)) x))
  (defun f3 (x) x)
  (defun f4p (x)
    (declare (xargs :mode :program))
    (list (f1p x) (f2p x) (f3 x))))
(verify-guards-program f4p :print t))

; No measure guessed:
(progn
  (defun f5p (x y)
    (declare (xargs :mode :program))
    (if (consp x)
        (f5p (cdr x) y)
      (if (consp y)
          (f5p x (cdr y))
        (list x y))))
  (defun f6p (x y)
    (declare (xargs :mode :program))
    (list (f4p x) (f5p x y))))
(verify-guards-program f6p :print t)

; Guard verification fails for f7p:
(defun f7p (x)
  (declare (xargs :mode :program))
  (car (f1p x)))
(verify-guards-program f7p :print t)

; Fails (tests that verify-termination doesn't do guard
; verification under skip-proofs):
(defun f8p (x)
  (declare (xargs :mode :program :guard (not (acl2-numberp x))))
  (car (f1p x)))
(verify-guards-program f8p)

; Succeeds
(defun f9p (x)
  (declare (xargs :mode :program :guard (consp x)))
  (car (f1p x)))
(verify-guards-program f9p)

; Fails
(verify-guards-program f0)

||#
