; APT (Automated Program Transformations) Library
;
; Copyright (C) 2020 Kestrel Institute (http://www.kestrel.edu)
;
; License: A 3-clause BSD license. See the LICENSE file distributed with ACL2.
;
; Author: Alessandro Coglio (coglio@kestrel.edu)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package "ACL2")

(include-book "kestrel/soft/defunvar" :dir :system)
(include-book "kestrel/soft/defun2" :dir :system)
(include-book "kestrel/soft/defun-sk2" :dir :system)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; This file contains macros to generate template functions and theorems
; of the kind processed and generated by DIVCONQ.
; These templates are useful to construct generic tests
; and to explicate proof generation strategies.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Generate a function variable.

(defmacro gen-funvar (&key name arity)
  `(defunvar ,name ,(repeat arity '*) => *))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Generate a function stub.

(defmacro gen-stub (&key name arity)
  `(defstub ,name ,(repeat arity '*) => *))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Generate the function OLD described in the user documentation.

(defmacro gen-old (&key (name 'old)
                        (?f '?f)
                        (iorel 'iorel)
                        (x 'x)
                        x1...
                        ...xn
                        a1...
                        ...am)
  (let ((x-x1...xn (append x1... (list x) ...xn))
        (x-a1...am (append a1... (list x) ...am)))
    `(defun-sk2 ,name ()
       (declare (xargs :guard t :verify-guards t))
       (forall ,x-x1...xn (,iorel ,@x-x1...xn (,?f ,@x-a1...am))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Generate the function FOLD[?F][?G] described in the user documentation.

(defmacro gen-fold (&key (name 'fold[?g][?h])
                         (?g '?g)
                         (?h '?h)
                         (x 'x)
                         z1...
                         ...zm
                         hints
                         guard-hints)
  (let ((x-z1...zm (append z1... (list x) ...zm)))
    `(defun2 ,name ,x-z1...zm
       (declare (xargs
                 :measure (acl2-count ,x)
                 ,@(and hints (list :hints hints))
                 :guard t
                 :verify-guards t
                 :guard-hints ,guard-hints))
       (cond ((atom ,x) (,?g ,@x-z1...zm))
             (t (,?h ,@z1...
                     (car ,x)
                     ,@...zm
                     (,name ,@z1... (cdr ,x) ,@...zm)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Generate the function SPEC-ATOM[?G] described in the user documentation.

(defmacro gen-spec-atom (&key (name 'spec-atom[?g])
                              (?g '?g)
                              (x 'x)
                              x1...
                              ...xn
                              a1...
                              ...am
                              (iorel 'iorel)
                              guard-hints)
  (let ((x-x1...xn (append x1... (list x) ...xn))
        (x-a1...am (append a1... (list x) ...am)))
    `(defun-sk2 ,name  ()
       (declare (xargs :guard t
                       :verify-guards t
                       :guard-hints ,guard-hints))
       (forall ,x-x1...xn
               (impliez (atom ,x)
                        (,iorel ,@x-x1...xn (,?g ,@x-a1...am)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Generate the function SPEC-CONS[?H] described in the user documentation.

(defmacro gen-spec-cons (&key (name 'spec-cons[?h])
                              (?h '?h)
                              (x 'x)
                              (y 'y)
                              x1...
                              ...xn
                              a1...
                              ...am
                              (iorel 'iorel)
                              guard-hints)
  (let ((x-x1...xn (append x1... (list x) ...xn)))
    `(defun-sk2 ,name ()
       (declare (xargs :guard t
                       :verify-guards t
                       :guard-hints ,guard-hints))
       (forall (,@x-x1...xn ,y)
               (impliez (and (consp ,x)
                             (,iorel ,@x1... (cdr ,x) ,@...xn ,y))
                        (iorel ,@x-x1...xn
                               (,?h ,@a1... (car ,x) ,@...am ,y)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Generate the function EQUAL[?F][FOLD[?G][?H]]
; described in the user documentation.

(defmacro gen-equal-fold (&key (name 'equal[?f][fold[?g][?h]])
                               (?f '?f)
                               (fold 'fold[?g][?h])
                               (x 'x)
                               z1...
                               ...zm
                               guard-hints)
  (let ((x-z1...zm (append z1... (list x) ...zm)))
    `(defun-sk2 ,name ()
       (declare (xargs :guard t
                       :verify-guards t
                       :guard-hints ,guard-hints))
       (forall ,x-z1...zm
               (equal (,?f ,@x-z1...zm)
                      (,fold ,@x-z1...zm))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Generate the function NEW described in the user documentation.

(defmacro gen-new (&key (name 'new)
                        (equal-fold 'equal[?f][fold[?g][?h]])
                        (spec-atom 'spec-atom[?g])
                        (spec-cons 'spec-cons[?h])
                        guard-hints)
  `(defun2 ,name ()
     (declare (xargs :guard t :verify-guards t :guard-hints ,guard-hints))
     (and (,equal-fold)
          (,spec-atom)
          (,spec-cons))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Generate the internal theorem FOLD-CORRECT
; (not described in the user documentation).

(defmacro gen-fold-correct (&key (name 'fold-correct)
                                 (spec-atom 'spec-atom[?g])
                                 (spec-cons 'spec-cons[?h])
                                 (fold 'fold[?g][?h])
                                 (x 'x)
                                 x1...
                                 ...xn
                                 a1...
                                 ...am
                                 (iorel 'iorel)
                                 hints)
  (let ((x-x1...xn (append x1... (list x) ...xn))
        (x-a1...am (append a1... (list x) ...am)))
    `(defthm ,name
       (implies (and (,spec-atom)
                     (,spec-cons))
                (,iorel ,@x-x1...xn (,fold ,@x-a1...am)))
       :hints ,hints)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Generate the theorem OLD-IF-NEW described in the user documentation.

(defmacro gen-old-if-new (&key (name 'old-if-new)
                               (old 'old)
                               (new 'new)
                               hints)
  `(defthm ,name
     (implies (,new)
              (,old))
     :hints ,hints))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Generate generic inputs of the transformation,
; for different values of n and m and
; different positions npos and mpos within 1,...,n and 1,...m
; (both npos and mpos are 0-based).

; generate list of variables X1, ..., Xn:
(defun gen-x1...xn (n)
  (cond ((zp n) nil)
        (t (append (gen-x1...xn (1- n)) (list (packn (list 'x n)))))))

; generate list of terms (A1 X1 ... Xn), ..., (Am X1 ... Xn):
(defun gen-a1...am (m x1...xn)
  (cond ((zp m) nil)
        (t (append (gen-a1...am (1- m) x1...xn)
                   (list `(,(packn (list 'a m)) ,@x1...xn))))))

; generate stubs for A1, ..., Am:
(defun gen-a1...am-stubs (m n)
  (cond ((zp m) nil)
        (t (append (gen-a1...am-stubs (1- m) n)
                   (list `(gen-stub :name ,(packn (list 'a m)) :arity ,n))))))

; generate generic inputs:
(defmacro gen-inputs (n npos m mpos)
  (let* ((x1...xn (gen-x1...xn n))
         (a1...am (gen-a1...am m x1...xn)))
    `(encapsulate ()
       (gen-funvar :name ?f :arity ,(1+ m))
       (gen-stub :name iorel :arity ,(+ 2 n))
       ,@(gen-a1...am-stubs m n)
       (gen-old :x1... ,(take npos x1...xn)
                :...xn ,(nthcdr npos x1...xn)
                :a1... ,(take mpos a1...am)
                :...am ,(nthcdr mpos a1...am)))))
