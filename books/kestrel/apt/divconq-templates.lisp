; APT (Automated Program Transformations) Library
;
; Copyright (C) 2020 Kestrel Institute (http://www.kestrel.edu)
;
; License: A 3-clause BSD license. See the LICENSE file distributed with ACL2.
;
; Author: Alessandro Coglio (coglio@kestrel.edu)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package "ACL2")

(include-book "kestrel/soft/defunvar" :dir :system)
(include-book "kestrel/soft/defun2" :dir :system)
(include-book "kestrel/soft/defun-sk2" :dir :system)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; This file contains macros to generate template functions and theorems
; of the kind processed and generated by DIVCONQ.
; These templates are useful to construct generic tests
; and to explicate proof generation strategies.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Generate a function variable.

(defmacro gen-funvar (&key name arity)
  `(defunvar ,name ,(repeat arity '*) => *))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Generate a function stub.

(defmacro gen-stub (&key name arity)
  `(defstub ,name ,(repeat arity '*) => *))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Generate (an abstract form of) the lambda expression for IOREL
; described in the user documentation.

(defmacro gen-iorel (&key name arity)
  `(defstub ,name ,(repeat arity '*) => *))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Generate the function OLD described in the user documentation.

(defmacro gen-old (&key name ?f vars iorel)
  `(defun-sk2 ,name ()
     (forall ,vars (,iorel ,@vars (,?f ,@vars)))))

; extension:
(defmacro gen-old-ext (&key (name 'old)
                            (?f '?f)
                            (iorel 'iorel)
                            (x 'x)
                            x1...
                            ...xn
                            a1...
                            ...am)
  (let ((x-x1...xn (append x1... (list x) ...xn))
        (x-a1...am (append a1... (list x) ...am)))
    `(defun-sk2 ,name ()
       (declare (xargs :guard t :verify-guards t))
       (forall ,x-x1...xn (,iorel ,@x-x1...xn (,?f ,@x-a1...am))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Generate the function FOLD[?F][?G] described in the user documentation.

(defmacro gen-fold (&key name ?g ?h vars1 var vars2 hints guard-hints)
  (let ((vars (append vars1 (list var) vars2)))
    `(progn
       (defun2 ,name ,vars
         (declare (xargs :measure (acl2-count ,var)
                    ,@(and hints (list :hints hints))))
         (cond ((atom ,var) (,?g ,@vars))
               (t (,?h ,@vars1
                       (car ,var)
                       ,@vars2
                       (,name ,@vars1 (cdr ,var) ,@vars2)))))
       (verify-guards ,name ,@(and guard-hints (list :hints guard-hints))))))

; extension:
(defmacro gen-fold-ext (&key (name 'fold[?g][?h])
                             (?g '?g)
                             (?h '?h)
                             (x 'x)
                             z1...
                             ...zm
                             hints
                             guard-hints)
  (let ((x-z1...zm (append z1... (list x) ...zm)))
    `(defun2 ,name ,x-z1...zm
       (declare (xargs
                 :measure (acl2-count ,x)
                 ,@(and hints (list :hints hints))
                 :guard t
                 :verify-guards t
                 :guard-hints ,guard-hints))
       (cond ((atom ,x) (,?g ,@x-z1...zm))
             (t (,?h ,@z1...
                     (car ,x)
                     ,@...zm
                     (,name ,@z1... (cdr ,x) ,@...zm)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Generate the function SPEC-ATOM[?G] described in the user documentation.

(defmacro gen-spec-atom (&key name ?g vars1 var vars2 iorel guard-hints)
  (let ((vars (append vars1 (list var) vars2)))
    `(progn
       (defun-sk2 ,name  ()
         (forall ,vars
                 (impliez (atom ,var)
                          (,iorel ,@vars (,?g ,@vars)))))
       (verify-guards ,name ,@(and guard-hints (list :hints guard-hints))))))

; extension:
(defmacro gen-spec-atom-ext (&key (name 'spec-atom[?g])
                                  (?g '?g)
                                  (x 'x)
                                  x1...
                                  ...xn
                                  a1...
                                  ...am
                                  (iorel 'iorel)
                                  guard-hints)
  (let ((x-x1...xn (append x1... (list x) ...xn))
        (x-a1...am (append a1... (list x) ...am)))
    `(defun-sk2 ,name  ()
       (declare (xargs :guard t
                       :verify-guards t
                       :guard-hints ,guard-hints))
       (forall ,x-x1...xn
               (impliez (atom ,x)
                        (,iorel ,@x-x1...xn (,?g ,@x-a1...am)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Generate the function SPEC-CONS[?H] described in the user documentation.

(defmacro gen-spec-cons (&key name ?h vars1 var vars2 cdrout iorel guard-hints)
  (let ((vars (append vars1 (list var) vars2)))
    `(progn
       (defun-sk2 ,name ()
         (forall (,@vars ,cdrout)
                 (impliez (and (consp ,var)
                               (,iorel ,@vars1 (cdr ,var) ,@vars2 ,cdrout))
                          (iorel ,@vars
                                 (,?h ,@vars1 (car ,var) ,@vars2 ,cdrout)))))
       (verify-guards ,name ,@(and guard-hints (list :hints guard-hints))))))

; extension:
(defmacro gen-spec-cons-ext (&key (name 'spec-cons[?h])
                                  (?h '?h)
                                  (x 'x)
                                  (y 'y)
                                  x1...
                                  ...xn
                                  a1...
                                  ...am
                                  (iorel 'iorel)
                                  guard-hints)
  (let ((x-x1...xn (append x1... (list x) ...xn)))
    `(defun-sk2 ,name ()
       (declare (xargs :guard t
                       :verify-guards t
                       :guard-hints ,guard-hints))
       (forall (,@x-x1...xn ,y)
               (impliez (and (consp ,x)
                             (,iorel ,@x1... (cdr ,x) ,@...xn ,y))
                        (iorel ,@x-x1...xn
                               (,?h ,@a1... (car ,x) ,@...am ,y)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Generate the function EQUAL[?F][FOLD[?G][?H]]
; described in the user documentation.

(defmacro gen-equal-fold (&key name ?f fold vars guard-hints)
  `(progn
     (defun-sk2 ,name ()
       (forall ,vars
               (equal (,?f ,@vars)
                      (,fold ,@vars))))
     (verify-guards ,name ,@(and guard-hints (list :hints guard-hints)))))

; extension:
(defmacro gen-equal-fold-ext (&key (name 'equal[?f][fold[?g][?h])
                                   (?f '?f)
                                   (fold 'fold[?g][?h])
                                   (x 'x)
                                   z1...
                                   ...zm
                                   guard-hints)
  (let ((x-z1...zm (append z1... (list x) ...zm)))
    `(defun-sk2 ,name ()
       (declare (xargs :guard t
                       :verify-guards t
                       :guard-hints ,guard-hints))
       (forall ,x-z1...zm
               (equal (,?f ,@x-z1...zm)
                      (,fold ,@x-z1...zm))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Generate the function NEW described in the user documentation.

(defmacro gen-new (&key (name 'new)
                        (equal-fold 'equal[?f][fold[?g][?h]])
                        (spec-atom 'spec-atom[?g])
                        (spec-cons 'spec-cons[?h])
                        guard-hints)
  `(defun2 ,name ()
     (declare (xargs :guard t :verify-guards t :guard-hints ,guard-hints))
     (and (,equal-fold)
          (,spec-atom)
          (,spec-cons))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Generate the theorem OLD-IF-NEW described in the user documentation.

(defmacro gen-old-if-new (&key (name 'old-if-new)
                               (old 'old)
                               (new 'new)
                               hints)
  `(defthm ,name
     (implies (,new)
              (,old))
     :hints ,hints))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Generate generic inputs of the transformation,
; for different arities and different positions of the list input.
; The name GEN-INPUTS-n-m means arity n and position m (0-based).

(defmacro gen-inputs-1-0 (&key (old 'old)
                               (iorel 'iorel)
                               (?f '?f)
                               (vars '(list)))
  `(encapsulate ()
     (gen-iorel :name ,iorel :arity 2)
     (gen-funvar :name ,?f :arity 1)
     (gen-old :name ,old :?f ,?f :vars ,vars :iorel ,iorel)))

(defmacro gen-inputs-2-0 (&key (old 'old)
                               (iorel 'iorel)
                               (?f '?f)
                               (vars '(list x)))
  `(encapsulate ()
     (gen-iorel :name ,iorel :arity 3)
     (gen-funvar :name ,?f :arity 2)
     (gen-old :name ,old :?f ?f :vars ,vars :iorel ,iorel)))

(defmacro gen-inputs-2-1 (&key (old 'old)
                               (iorel 'iorel)
                               (?f '?f)
                               (vars '(x list)))
  `(encapsulate ()
     (gen-iorel :name ,iorel :arity 3)
     (gen-funvar :name ,?f :arity 2)
     (gen-old :name ,old :?f ?f :vars ,vars :iorel ,iorel)))

(defmacro gen-inputs-3-0 (&key (old 'old)
                               (iorel 'iorel)
                               (?f '?f)
                               (vars '(list x y)))
  `(encapsulate ()
     (gen-iorel :name ,iorel :arity 4)
     (gen-funvar :name ,?f :arity 3)
     (gen-old :name ,old :?f ?f :vars ,vars :iorel ,iorel)))

(defmacro gen-inputs-3-1 (&key (old 'old)
                               (iorel 'iorel)
                               (?f '?f)
                               (vars '(x list y)))
  `(encapsulate ()
     (gen-iorel :name ,iorel :arity 4)
     (gen-funvar :name ,?f :arity 3)
     (gen-old :name ,old :?f ?f :vars ,vars :iorel ,iorel)))

(defmacro gen-inputs-3-2 (&key (old 'old)
                               (iorel 'iorel)
                               (?f '?f)
                               (vars '(x y list)))
  `(encapsulate ()
     (gen-iorel :name ,iorel :arity 4)
     (gen-funvar :name ,?f :arity 3)
     (gen-old :name ,old :?f ?f :vars ,vars :iorel ,iorel)))

(defmacro gen-inputs-4-0 (&key (old 'old)
                               (iorel 'iorel)
                               (?f '?f)
                               (vars '(list x y z)))
  `(encapsulate ()
     (gen-iorel :name ,iorel :arity 5)
     (gen-funvar :name ,?f :arity 4)
     (gen-old :name ,old :?f ?f :vars ,vars :iorel ,iorel)))

(defmacro gen-inputs-4-1 (&key (old 'old)
                               (iorel 'iorel)
                               (?f '?f)
                               (vars '(x list y z)))
  `(encapsulate ()
     (gen-iorel :name ,iorel :arity 5)
     (gen-funvar :name ,?f :arity 4)
     (gen-old :name ,old :?f ?f :vars ,vars :iorel ,iorel)))

(defmacro gen-inputs-4-2 (&key (old 'old)
                               (iorel 'iorel)
                               (?f '?f)
                               (vars '(x y list z)))
  `(encapsulate ()
     (gen-iorel :name ,iorel :arity 5)
     (gen-funvar :name ,?f :arity 4)
     (gen-old :name ,old :?f ?f :vars ,vars :iorel ,iorel)))

(defmacro gen-inputs-4-3 (&key (old 'old)
                               (iorel 'iorel)
                               (?f '?f)
                               (vars '(x y z list)))
  `(encapsulate ()
     (gen-iorel :name ,iorel :arity 5)
     (gen-funvar :name ,?f :arity 4)
     (gen-old :name ,old :?f ?f :vars ,vars :iorel ,iorel)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; extension:

; Generate generic inputs of the transformation,
; for different values of n and m and
; different positions npos and mpos within 1,...,n and 1,...m
; (both npos and mpos are 0-based).

; generate list of variables X1, ..., Xn:
(defun gen-x1...xn (n)
  (cond ((zp n) nil)
        (t (append (gen-x1...xn (1- n)) (list (packn (list 'x n)))))))

; generate list of terms (A1 X1 ... Xn), ..., (Am X1 ... Xn):
(defun gen-a1...am (m x1...xn)
  (cond ((zp m) nil)
        (t (append (gen-a1...am (1- m) x1...xn)
                   (list `(,(packn (list 'a m)) ,@x1...xn))))))

; generate stubs for A1, ..., Am:
(defun gen-a1...am-stubs (m n)
  (cond ((zp m) nil)
        (t (append (gen-a1...am-stubs (1- m) n)
                   (list `(gen-stub :name ,(packn (list 'a m)) :arity ,n))))))

; generate generic inputs:
(defmacro gen-inputs (n npos m mpos)
  (let* ((x1...xn (gen-x1...xn n))
         (a1...am (gen-a1...am m x1...xn)))
    `(encapsulate ()
       (gen-funvar :name ?f :arity ,(1+ m))
       (gen-stub :name iorel :arity ,(+ 2 n))
       ,@(gen-a1...am-stubs m n)
       (gen-old-ext :x1... ,(take npos x1...xn)
                    :...xn ,(nthcdr npos x1...xn)
                    :a1... ,(take mpos a1...am)
                    :...am ,(nthcdr mpos a1...am)))))
