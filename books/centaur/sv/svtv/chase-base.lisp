; SV - Symbolic Vector Hardware Analysis Framework
; Copyright (C) 2014-2015 Centaur Technology
;
; Contact:
;   Centaur Technology Formal Verification Group
;   7600-C N. Capital of Texas Highway, Suite 300, Austin, TX 78731, USA.
;   http://www.centtech.com/
;
; License: (An MIT/X11-style license)
;
;   Permission is hereby granted, free of charge, to any person obtaining a
;   copy of this software and associated documentation files (the "Software"),
;   to deal in the Software without restriction, including without limitation
;   the rights to use, copy, modify, merge, publish, distribute, sublicense,
;   and/or sell copies of the Software, and to permit persons to whom the
;   Software is furnished to do so, subject to the following conditions:
;
;   The above copyright notice and this permission notice shall be included in
;   all copies or substantial portions of the Software.
;
;   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
;   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
;   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;   DEALINGS IN THE SOFTWARE.
;
; Original authors: Sol Swords <sswords@centtech.com>

(in-package "SV")

;; (include-book "debug")
(include-book "eval-phases")
(include-book "probe")
(include-book "fsm-obj")
(include-book "../svex/rewrite")
(include-book "../mods/moddb")
(include-book "../mods/path-string")
(include-book "std/strings/hexify" :dir :system)
(include-book "expand")
(include-book "../svex/env-ops")
(include-book "../svex/override-types")
;; (include-book "std/stobjs/updater-independence" :dir :system)
;; This tool operates from an initialized DEBUGDATA stobj, as generated by
;; svtv-debug-core, or (without dumping a vcd) by svtv-debug-init followed by
;; svtv-debug-set-svtv.

;; It takes an input alist and expands it to an environment for each phase and
;; initial state so that we can evaluate a signal at a given phase.

;; Then we start from some given signal (an output/internal name or path and
;; phase).  We can evaluate that signal using svex-eval-svtv-phases.


(defprod chase-position
  ((path path-p)
   ;; Integerp largely because it's occasionally convenient to have a phase of -1 to denote initial states.
   (phase integerp :rule-classes :type-prescription)
   (rsh natp :rule-classes :type-prescription)
   (mask 4vmask-p)))


(deflist chase-stack :elt-type chase-position :true-listp t)



(local (defun svtv-chase-data-renaming (field-names)
         (b* (((when (atom field-names)) nil)
              (field (car field-names))
              (new-field (intern$ (cat "SVTV-CHASE-DATA->" (symbol-name field)) "SV"))
              (update (intern$ (cat "UPDATE-" (symbol-name field)) "SV"))
              (new-update (intern$ (cat "SET-SVTV-CHASE-DATA->" (symbol-name field)) "SV"))
              (pred (intern$ (cat (symbol-name field) "P") "SV"))
              (new-pred (intern$ (cat "SVTV-CHASE-DATA->" (symbol-name field) "P") "SV")))
           (cons (list field new-field)
                 (cons (list update new-update)
                       (cons (list pred new-pred)
                             (svtv-chase-data-renaming (cdr field-names))))))))

(make-event
 (b* ((fields
       `((stack :type (satisfies chase-stack-p) :initially nil)
         (sigtype :type symbol)
         (vars :type (satisfies 4vmask-alist-p))
         (expr :type (satisfies svex-p) :initially ,(svex-x))
         ;; (new-phase :type (integer 0 *) :initially 0)
         (evaldata :type (satisfies svtv-evaldata-p) :initially ,(make-svtv-evaldata))
         (smartp :initially t)
         (phaselabels :type (satisfies symbol-listp))
         (updates :type (satisfies svex-alist-p))
         (delays :type (satisfies svex-alist-p))
         (assigns :type (satisfies svex-alist-p))
         (override-alist :type (satisfies svex-alist-p))
         (modidx :type (integer 0 *) :initially 0)
         (probes :type (satisfies svtv-probealist-p))
         (namemap :type (satisfies svtv-name-lhs-map-p))
         (print-with-mask-mode :type symbol :initially :default)
         (print-overrides-mode :type symbol :initially nil)))
      (field-names (strip-cars fields))
      (renaming (svtv-chase-data-renaming field-names))
      ;; (fns (append '(debugdatap create-debugdata)
      ;;              (acl2::strip-cadrs renaming)))
      (make-binder (std::da-make-binder 'svtv-chase-data field-names)))
   
   `(progn
      (defstobj svtv-chase-data
        ,@fields
        :renaming ,renaming)
      (in-theory (disable create-svtv-chase-data svtv-chase-datap))
      ,make-binder)))





;; There are basically three types of signals/svex variables used here:
;;  - If V is a key of nextstates/delays, then it is a previous state signal.
;;  - If V is a key of updates/assigns, then it is an internal signal.
;;  - If V appears in an expression (value) of updates or nextstates but is not
;;  a key of either one, then it is a primary input.

;;    A previous state signal cannot also be an internal signal (a key of
;;    nextstates cannot also be a key of updates).  But each V that is a
;;    previous state/key of updates is also a key of delays, and the
;;    corresponding value in delays is an internal signal or primary input that
;;    is also the nextstate of V.

;; The keys of nextstates should be the same as those of delays.  The keys of
;; updates should be the same as those of assigns.


;; We want to support exploring the design by walking through following
;; dependencies back to drivers. Generally we'll have a stack starting from
;; some signal and going back though its drivers (across phases).

;; The current position will be tracked as a variable, phase, right-shift, and
;; mask.  The mask is relative to the right-shift, so the caremask for the
;; whole variable is mask << right-shift.

;; We'll find dependencies of a variable modulo the caremask, and the resulting
;; dependency variables will be reported along with their caremasks.
;; Internally we'll use right-shifts and masks, but when we print things out to
;; the user we'll want to translate back to relative indices.  E.g. if a
;; variable is declared as x[10:2] and we have a rightshift of 3 and mask
;; #b101, we'll show the range as x[7:5].


(define svtv-chase-normalize-var/phase ((var svar-p)
                                        (phase integerp))
  :returns (mv (new-var svar-p)
               (new-phase natp :rule-classes :type-prescription))
  (b* (((svar var))
       (eff-delay (min var.delay (lifix phase)))
       (new-delay (- var.delay eff-delay)))
    (mv (change-svar var :delay new-delay) (- (lifix phase) eff-delay)))
  ///
  ;; (defret svar-addr-p-of-<fn>
  ;;   (implies (svar-addr-p var)
  ;;            (svar-addr-p new-var))
  ;;   :hints(("Goal" :in-theory (enable svar-addr-p))))
  )

(define svtv-chase-eval-override ((var svar-p)
                                       (phase integerp)
                                       &key
                                       (svtv-chase-data 'svtv-chase-data))
  :returns (mv (override-mask integerp)
               (override-val 4vec-p)
               (computed-val 4vec-p))
  :guard-hints ((and stable-under-simplificationp
                     '(:in-theory (enable svtv-chase-datap))))
  (b* (((mv var phase) (svtv-chase-normalize-var/phase var phase))
       ((svtv-chase-data svtv-chase-data))
       ((svtv-evaldata evaldata) svtv-chase-data.evaldata)
       ((when (< 0 (svar->delay var)))
        (b* ((val (svex-env-lookup var evaldata.initst)))
          (mv 0 0 val)))
       (override-mux (svex-fastlookup var svtv-chase-data.override-alist))
       (computed-expr (svex-compose (svex-var var) svtv-chase-data.updates))
       (computed-val (svex-eval-svtv-phases computed-expr phase evaldata))
       ((unless override-mux)
        (mv 0 0 computed-val))
       (override-test-expr (svex-var (svar-change-override var :test)))
       (override-val-expr (svex-var (svar-change-override var :val))))
    (mv (4vec-1mask (svex-eval-svtv-phases override-test-expr phase evaldata))
        (svex-eval-svtv-phases override-val-expr phase evaldata)
        computed-val)))
  
(define svtv-chase-eval ((var svar-p)
                         (phase integerp)
                         &key
                         (svtv-chase-data 'svtv-chase-data))
  :returns (val 4vec-p)
  :guard-hints ((and stable-under-simplificationp
                     '(:in-theory (enable svtv-chase-datap))))
  (b* (((mv var phase) (svtv-chase-normalize-var/phase var phase))
       ((svtv-chase-data svtv-chase-data))
       ((svtv-evaldata evaldata) svtv-chase-data.evaldata)
       ((when (< 0 (svar->delay var)))
        (svex-env-lookup var evaldata.initst))
       (override-mux (svex-fastlookup var svtv-chase-data.override-alist))
       (overridden-val (svex-compose (or override-mux (svex-var var)) svtv-chase-data.updates)))
    (svex-eval-svtv-phases overridden-val phase evaldata)))


(define svtv-chase-evallist ((vars svarlist-p)
                             (phase integerp)
                             &key
                             (svtv-chase-data 'svtv-chase-data))
  :returns (vals 4veclist-p)
  (if (atom vars)
      nil
    (cons (svtv-chase-eval (car vars) phase)
          (svtv-chase-evallist (cdr vars) phase)))
  ///
  (defret len-of-<fn>
    (equal (len vals) (len vars))))
       


(define svex-mask-alist-to-4vmask-alist ((x svex-mask-alist-p))
  :returns (new-x 4vmask-alist-p)
  (if (atom x)
      nil
    (if (and (mbt (and (consp (car x)) (svex-p (caar x))))
             (svex-case (caar x) :var)
             (not (sparseint-equal (cdar x) 0)))
        (cons (cons (svex-var->name (caar x))
                    (sparseint-fix (cdar x)))
              (svex-mask-alist-to-4vmask-alist (cdr x)))
      (svex-mask-alist-to-4vmask-alist (cdr x)))))


(local (defthm svarlist-p-alist-keys-when-4vmask-alist-p
         (implies (4vmask-alist-p x)
                  (svarlist-p (alist-keys x)))
         :hints(("Goal" :in-theory (enable alist-keys)))))


;; (local
;;  (defsection svarlist-addr-p-of-svexlist-compute-masks
;;    (defret member-vars-of-svex-args-apply-masks
;;      (implies (and (not (member v (svexlist-vars args)))
;;                    (not (member v (svexlist-vars (svex-mask-alist-keys mask-al)))))
;;               (not (member v (svexlist-vars (svex-mask-alist-keys mask-al1)))))
;;      :hints(("Goal" :in-theory (enable svex-args-apply-masks)))
;;      :fn svex-args-apply-masks)

;;    (defret member-vars-of-svexlist-compute-masks
;;      (implies (and (not (member v (svexlist-vars x)))
;;                    (not (member v (svexlist-vars (svex-mask-alist-keys mask-al)))))
;;               (not (member v (svexlist-vars (svex-mask-alist-keys mask-al1)))))
;;      :hints(("Goal" :in-theory (enable svexlist-compute-masks)))
;;      :fn svexlist-compute-masks)

;;    (defret member-alist-keys-of-svex-mask-alist-to-4vmask-alist
;;      (implies (not (member v (svexlist-vars (svex-mask-alist-keys x))))
;;               (not (member v (alist-keys new-x))))
;;      :hints(("Goal" :in-theory (enable svex-mask-alist-to-4vmask-alist
;;                                        svex-mask-alist-keys
;;                                        alist-keys)))
;;      :fn svex-mask-alist-to-4vmask-alist)))


(local (in-theory (disable fast-alist-clean)))

(local
 (encapsulate nil
   (defthm svex-mask-alist-p-of-fast-alist-fork
     (implies (and (svex-mask-alist-p x)
                   (svex-mask-alist-p y))
              (svex-mask-alist-p (fast-alist-fork x y))))

   (local (defthm cdr-last-when-svex-mask-alist-p
            (implies (svex-mask-alist-p x)
                     (equal (cdr (last x)) nil))))



   (defthm svex-mask-alist-p-of-fast-alist-clean
     (implies (svex-mask-alist-p x)
              (svex-mask-alist-p (fast-alist-clean x)))
     :hints(("Goal" :in-theory (enable fast-alist-clean svex-mask-alist-p))))))



(define svexlist-compute-masks-with-eval ((x svexlist-p)
                                          (mask-al svex-mask-alist-p)
                                          (env svex-env-p))
  :returns (mask-al1 svex-mask-alist-p)
  (b* (((when (atom x))
        (mbe :logic (svex-mask-alist-fix mask-al)
             :exec mask-al))
       (first (car x))
       ((when (not (eq (svex-kind first) :call)))
        (svexlist-compute-masks-with-eval (cdr x) mask-al env))
       (mask (svex-mask-lookup first mask-al))
       ((when (sparseint-equal mask 0))
        (svexlist-compute-masks-with-eval (cdr x) mask-al env))
       (args (svex-call->args first))
       (argvals (4veclist-quote (svexlist-eval args env)))
       (argmasks (svex-argmasks mask
                                (svex-call->fn first)
                                argvals))
       (mask-al (svex-args-apply-masks args argmasks mask-al)))
    (svexlist-compute-masks-with-eval (cdr x) mask-al env)))

(define svtv-chase-expr-deps ((expr svex-p)
                              (phase natp)
                              (rsh natp)
                              (mask 4vmask-p)
                              &key
                              (svtv-chase-data 'svtv-chase-data))
  :returns (deps svex-mask-alist-p)
  (b* (((mv toposort al) (svex-toposort expr nil nil))
       (- (fast-alist-free al))
       ((svtv-chase-data svtv-chase-data))
       (start-mask-al (svex-mask-acons expr (sparseint-ash mask rsh) nil))
       ((unless svtv-chase-data.smartp)
        (fast-alist-free
         (fast-alist-clean
          (svexlist-compute-masks toposort start-mask-al))))
       (vars (svex-collect-vars expr))
       (env (make-fast-alist (pairlis$ vars (svtv-chase-evallist vars phase))))
       (mask-al (fast-alist-free
                 (fast-alist-clean
                  (svexlist-compute-masks-with-eval
                   toposort (svex-mask-acons expr (sparseint-ash mask rsh) nil)
                   env)))))
    (fast-alist-free env)
    mask-al))
       




(define svtv-chase-deps ((var svar-p)
                         (phase natp)
                         (rsh natp)
                         (mask 4vmask-p)
                         &key
                         (svtv-chase-data 'svtv-chase-data))
  :guard-hints ((and stable-under-simplificationp
                     '(:in-theory (enable svtv-chase-datap))))
  :returns (mv (type symbolp :rule-classes :type-prescription)
               (vars 4vmask-alist-p)
               (expr svex-p))
  (b* (((svtv-chase-data svtv-chase-data))
       (phase (lnfix phase))
       (var (svar-fix var))
       (type
        (b* ((svex (svex-fastlookup var svtv-chase-data.updates))
             ((when svex)
              :update)
             (prev-var-look (hons-get var (svex-alist-fix svtv-chase-data.delays)))
             ((when prev-var-look)
              (if (eql phase 0)
                  :initst
                :prevst)))
          :input))

       ((when (or (eq type :input)
                  (eq type :initst)))
        (mv type nil (svex-var var)))

       ((when (eq type :prevst))
        (mv type (list (cons var (sparseint-ash mask rsh)))
            (svex-var var)))

       (expr (svex-fastlookup var svtv-chase-data.assigns))

       ((unless expr)
        (mv :error nil (svex-x)))

       (mask-al (svtv-chase-expr-deps expr phase rsh mask))
       
       (vars (svex-mask-alist-to-4vmask-alist mask-al)))
    (mv type vars expr))
  ///
  ;; (local (defthm svar-addr-p-lookup-in-svar-map
  ;;          (implies (And (svarlist-addr-p (svar-map-vars x))
  ;;                        (hons-assoc-equal k (svar-map-fix x)))
  ;;                   (svar-addr-p (cdr (hons-assoc-equal k (svar-map-fix x)))))
  ;;          :hints(("Goal" :in-theory (e/d (svar-map-vars svar-map-fix)
  ;;                                         (hons-assoc-equal-of-svar-map-fix))
  ;;                  :induct (svar-map-vars x)))
  ;;          :rule-classes
  ;;          ((:rewrite :corollary
  ;;            (implies (And (svarlist-addr-p (svar-map-vars x))
  ;;                          (svar-p k)
  ;;                          (hons-assoc-equal k x))
  ;;                   (svar-addr-p (cdr (hons-assoc-equal k x))))))))

  ;; (local (defthm member-svex-mask-alist-keys-of-fast-alist-fork
  ;;          (implies (and (not (member v (svexlist-vars (svex-mask-alist-keys x))))
  ;;                        (not (member v (svexlist-vars (svex-mask-alist-keys y)))))
  ;;                   (not (member v (svexlist-vars (svex-mask-alist-keys (fast-alist-fork x y))))))
  ;;          :hints(("Goal" :in-theory (enable svex-mask-alist-keys)))))

  ;; (local (defthm svex-mask-alist-keys-of-atom
  ;;          (implies (atom x)
  ;;                   (equal (svex-mask-alist-keys x) nil))
  ;;          :hints(("Goal" :in-theory (enable svex-mask-alist-keys)))))

  ;; (defret svarlist-addr-p-of-<fn>
  ;;   (implies (and (svar-addr-p var)
  ;;                 (svarlist-addr-p (svex-alist-vars (debugdata->override-assigns debugdata)))
  ;;                 (svarlist-addr-p (svar-map-vars (debugdata->delays debugdata))))
  ;;            (svarlist-addr-p (alist-keys vars)))
  ;;   :hints(("Goal" :in-theory (enable alist-keys))))

  

  ;; (defret svarlist-addr-p-expr-of-<fn>
  ;;   (implies (and (svar-addr-p var)
  ;;                 (svarlist-addr-p (svex-alist-vars (debugdata->override-assigns debugdata)))
  ;;                 (svarlist-addr-p (svar-map-vars (debugdata->delays debugdata))))
  ;;            (svarlist-addr-p (svex-vars expr)))
  ;;   :hints(("Goal" :in-theory (enable alist-keys))))
  )


(define svtv-chase-normalize-mask ((rsh natp) (mask 4vmask-p))
  :returns (mv (new-rsh natp :rule-classes :type-prescription)
               (new-mask 4vmask-p))
  (b* ((mask-rsh (sparseint-trailing-0-count mask))
       (norm-mask (sparseint-ash mask (- mask-rsh))))
    (mv (+ mask-rsh (lnfix rsh)) norm-mask))
  ///
  (local (include-book "centaur/bitops/ihsext-basics" :dir :system))
  (local (include-book "arithmetic/top" :dir :system))

  (local (defthm ash-of-trailing-0-count
           (equal (ash (logtail (bitops::trailing-0-count x) x)
                       (bitops::trailing-0-count x))
                  (ifix x))
           :hints(("Goal" :in-theory (enable* bitops::trailing-0-count
                                              bitops::ihsext-recursive-redefs)))))

  (defret <fn>-correct
    (equal (ash (sparseint-val new-mask) new-rsh)
           (ash (sparseint-val mask) (nfix rsh)))
    :hints (("goal" :in-theory (disable bitops::ash-of-ash)
             :use ((:instance bitops::ash-of-ash
                    (x (LOGTAIL (BITOPS::TRAILING-0-COUNT (SPARSEINT-VAL MASK))
                                (SPARSEINT-VAL MASK)))
                    (sh1 (BITOPS::TRAILING-0-COUNT (SPARSEINT-VAL MASK)))
                    (sh2 (nfix rsh))))))))

(define svtv-chase-var-declared-width ((var svar-p)
                                       (modidx natp)
                                       &key
                                       ((moddb moddb-ok) 'moddb))
  :returns (width maybe-posp :rule-classes :type-prescription)
  :guard (< modidx (moddb->nmods moddb))
  (b* (((svar var))
       ((unless (address-p var.name)) nil)
       (path (address->path var.name))
       ((mv err wire & &) (moddb-path->wireidx/decl path modidx moddb))
       ((when err) nil)
       ((wire wire)))
    wire.width))


(define svtv-chase-var-name/range ((var svar-p)
                                   (rsh natp)
                                   (mask 4vmask-p)
                                   (modidx natp)
                                   &key
                                   ((moddb moddb-ok) 'moddb))
  :returns (mv (name-range-msg)
               (width maybe-posp :rule-classes :type-prescription))
  :guard (< modidx (moddb->nmods moddb))
  (b* (((svar var))
       (maskwidth (and (not (sparseint-< mask 0))
                       (sparseint-length mask)))
       ((unless (address-p var.name))
        (b* (((when maskwidth)
              (mv (msg "~x0[~x1:~x2]" var.name (1- maskwidth) rsh) (max 1 maskwidth))))
          (cw! "Warning: For non-address variable ~x0, caremask was ~
                unbounded!~%" var)
          (mv (msg "~x0[??:~x1]" var.name rsh) nil)))
       (path (address->path var.name))
       (name (path->string-top path))
       ((mv err wire & &) (moddb-path->wireidx/decl path modidx moddb))
       ((when err)
        (cw! "[ERROR finding wire ~s0]: ~@1~%" (path->string-top path) err)
        (b* (((when maskwidth)
              (mv (msg "~s0[~x1:~x2]" name (1- maskwidth) rsh) (max 1 maskwidth))))
          (cw! "Warning: For unrecognized wire ~s0, caremask was unbounded!~%" name)
          (mv (msg "~s0[??:~x1]" (path->string-top path) rsh) nil)))
       ((wire wire))
       (width (if maskwidth
                  (min (max 1 maskwidth) wire.width)
                wire.width))
       (lsb (if wire.revp
                (- (+ wire.low-idx (- wire.width 1)) rsh)
              (+ rsh wire.low-idx)))
       (msb (if wire.revp
                (- lsb (- width 1))
              (+ lsb (- width 1)))))
    (mv (msg "~s0[~x1:~x2]" name msb lsb) width)))

;;  signame[4:0]:                #ux1E
;;  caremask:                    #ux1F
;; Value results from an override--
;;  override mask:                #uxc
;;  override value:               #uxf
;;  computed value:              #ux16
;; (Phase NEXT-PHASE = #x1.)


;; Printing for Chase --

;; Most things we print have a label on the left and a 4vec or integer value on
;; the right, to be printed in hex. We want to right-justify all such integer
;; and 4vec values to the same point in the line.  Unfortunately, though, we
;; need to support arbitrary ACL2 msg objects as the labels in the left column,
;; which means we can't determine how wide they will print.  Instead, we'll
;; just arbitrarily fix a left column width and use the ~t directive to tab out
;; to it, which means if the message doesn't fit in that width we'll just go to
;; the next line.

;; Non-integer 4vec values will be printed as:     ( #uxabcdabcd        ;; <-- "upper"
;;                                                   . #uxcadbca )      ;; <-- "lower"
;; Non-integer 4vec values will be printed as:    ( #uxABCD_ABCD
;;                                                  . #uxCA_DBCA )       (actual output)
;; If the "lower" is longer then it might instead look like:
;;                                                 (     #uxabcd        ;; <-- "upper"
;;                                                  . #uxdcbabcd )      ;; <-- "lower"
;; If the "lower" is longer then it might instead look like:
;;                                                (      #uxABCD
;;                                                 . #uxDCB_ABCD )       (actual output)
;;  -- the left paren is always at least 1 character to the left of the dot
;;  -- the dot is always one space before from the start of the "lower"
;;  -- the right paren is one space after the end of the "lower"
;;  -- the rightmost characters of "upper" and "lower" are in the same column.
;; Integer values are printed lined up with the 4vec uppers and lowers
;;  as in:                                                #ux10a
;;  as in:                                                #ux10A         (actual output)
;; We also allow lines with strings only and no 4vec.


;; BOZO we should put this in a more general book
(define msg-fix ((x msgp))
  :returns (new-x msgp)
  :inline t
  (mbe :logic (if (msgp x) x "")
       :exec x)
  ///
  (defthm msg-fix-when-msgp
    (implies (msgp x)
             (equal (msg-fix x) x)))

  (defthm msgp-of-msg
    (implies (and (stringp str)
                  (character-alistp args))
             (msgp (cons str args))))

  (defthm msgp-of-str
    (implies (stringp x)
             (msgp x)))
  
  (in-theory (disable msgp))
  
  (fty::deffixtype msg :pred msgp :fix msg-fix :equiv msg-equiv :define t))

(defprod 2col4vecline
  ((label msgp)
   (val maybe-4vec-p))
  :layout :tree)

(deflist 2col4vecs :elt-type 2col4vecline :true-listp t)

(define 4vec-print-width ((x 4vec-p))
  :returns (width posp :rule-classes :type-prescription)
  (if (2vec-p x)
      (length (str::hexify (2vec->val x)))
    (max (+ 3 (length (str::hexify (4vec->lower x))))
         (+ 2 (length (str::hexify (4vec->upper x)))))))

(define 2col4vec-min-space-between-columns ()
  :inline t
  4)

(define 2col4vec-left-column-width ()
  :inline t
  40)

(define 2col4vecline-width ((x 2col4vecline-p))
  :returns (width posp :rule-classes :type-prescription)
  (b* (((2col4vecline x)))
    (+ (2col4vec-min-space-between-columns)
       (if x.val (4vec-print-width x.val) 0))))

(define 2col4vecs-max-width ((x 2col4vecs-p))
  ;; this is the max width of the right column only
  :returns (width posp :rule-classes :type-prescription)
  (if (atom x)
      (2col4vec-min-space-between-columns)
    (max (2col4vecline-width (car x))
         (2col4vecs-max-width (cdr x)))))

(local (in-theory (disable hexify explode-atom max)))

(define print-2col4vecline ((right-column-width posp)
                            (x 2col4vecline-p))
  :returns (msg msgp)
  (b* (((2col4vecline x))
       ((unless x.val)
        (msg "~@0~%" x.label))
       ((when (2vec-p x.val))
        (b* ((valstr (str::hexify (2vec->val x.val)))
             (vallen (length valstr))
             (spaces (- (lposfix right-column-width) vallen)))
          (msg "~@0~t1~_2~s3~%" x.label (2col4vec-left-column-width) spaces valstr)))
       ((4vec x.val))
       (upper-str (str::hexify x.val.upper))
       (lower-str (str::hexify x.val.lower))
       (upperlen (length upper-str))
       (lowerlen (length lower-str))
       (vallen (max (+ 3 lowerlen) (+ 2 upperlen)))
       (spaces-before-lparen (- (lposfix right-column-width) vallen))
       (spaces-after-lparen (+ 1 (max 0 (+ 1 (- lowerlen upperlen)))))
       (spaces-before-dot   (- (lposfix right-column-width) (+ 2 lowerlen))))
    (msg "~@0~t1~_2(~_3~s4~%~t5~_6. ~s7 )~%"
         x.label
         (2col4vec-left-column-width)
         spaces-before-lparen
         spaces-after-lparen
         upper-str
         (2col4vec-left-column-width)
         spaces-before-dot
         lower-str)))

(define print-2col4vecs-aux ((right-column posp)
                             (x 2col4vecs-p))
  :returns (msg msgp)
  (if (atom x)
      ""
    (msg "~@0~@1"
         (print-2col4vecline right-column (car x))
         (print-2col4vecs-aux right-column (cdr x)))))

(define print-2col4vecs ((x 2col4vecs-p))
  :returns (msg msgp)
  (b* ((right-column (2col4vecs-max-width x)))
    (print-2col4vecs-aux right-column x)))


#||
(set-fmt-hard-right-margin 200 state)
(set-fmt-soft-right-margin 100 state)
(cw "~@0"
(print-2col4vecs
 (list
  (2col4vecline "Most things we print have a label on the left and a 4vec or integer value on" nil)
  (2col4vecline "the right, to be printed in hex. We want to right-justify all such integer" nil)
  (2col4vecline "and 4vec values to the same point in the line." nil)
  (2col4vecline "Non-integer 4vec values will be printed as:"
                (4vec #uxabcdabcd #uxcadbca ))
  (2col4vecline "If the \"lower\" is longer then it" nil)
  (2col4vecline "might instead look like:" (4vec #uxabcd #uxdcbabcd ))
  (2col4vecline " -- the left paren is always at least 1 character to the left of the dot" nil)
  (2col4vecline " -- the dot is always one space before from the start of the \"lower\"" nil)
  (2col4vecline " -- the right paren is one space after the end of the \"lower\"" nil)
  (2col4vecline " -- the rightmost characters of \"upper\" and \"lower\" are in the same column." nil)
  (2col4vecline "Integer values are printed lined up with the 4vec uppers and lowers" nil)
  (2col4vecline " as in:" #ux10a)
  (2col4vecline "We also allow lines with strings only and no 4vec." nil))))

;; should output (minus the ";; " left column:)

;; Most things we print have a label on the left and a 4vec or integer value on
;; the right, to be printed in hex. We want to right-justify all such integer
;; and 4vec values to the same point in the line.
;; Non-integer 4vec values will be printed as:                  ( #uxABCD_ABCD
;;                                                                . #uxCA_DBCA )
;; If the "lower" is longer then it might instead look like:    (      #uxABCD
;;                                                               . #uxDCB_ABCD )
;;  -- the left paren is always at least 1 character to the left of the dot
;;  -- the dot is always one space before from the start of the "lower"
;;  -- the right paren is one space after the end of the "lower"
;;  -- the rightmost characters of "upper" and "lower" are in the same column.
;; Integer values are printed lined up with the 4vec uppers and lowers
;;  as in:                                                              #ux10A
;; We also allow lines with strings only and no 4vec.
||#

(define 2col4vec-maybe-line (cond
                             (label msgp)
                             (val maybe-4vec-p))
  :returns (line 2col4vecs-p)
  (and cond
       (list (2col4vecline label val))))

(define maybe-loghead ((width maybe-posp)
                       (x integerp))
  :returns (new-x integerp :rule-classes :type-prescription)
  (if width (loghead (lposfix width) x) (lifix x)))

(define maybe-4vec-zero-ext ((width maybe-posp)
                             (x 4vec-p))
  :returns (new-x 4vec-p)
  (if width (4vec-zero-ext (2vec (lposfix width)) x) (4vec-fix x)))

(define svtv-chase-print-signal ((index acl2::maybe-natp "index to print at the beginning, if applicable")
                                 (var svar-p)
                                 (phase natp)
                                 (rsh natp)
                                 (mask 4vmask-p)
                                 (print-overrides)
                                 &key
                                 ((moddb moddb-ok) 'moddb)
                                 (svtv-chase-data 'svtv-chase-data))
  :guard (and ;; (svar-addr-p var)
          (< (svtv-chase-data->modidx svtv-chase-data) (moddb->nmods moddb)))
  :prepwork ((local (in-theory (e/d (svar-addr-p)
                                    (str::hexify max member-equal ash logior logxor lognot
                                                 append acl2::append-of-cons
                                                 acl2::append-when-not-consp not
                                                 moddb->nmods moddb->nmods1p
                                                 nth
                                                 moddbp)))))
  :guard-hints ((and stable-under-simplificationp
                     '(:in-theory (enable svtv-chase-datap))))
  :returns (lines 2col4vecs-p)

  (b* (((mv rsh mask) (svtv-chase-normalize-mask rsh mask))
       ((mv name/range width)
        (svtv-chase-var-name/range var rsh mask (svtv-chase-data->modidx svtv-chase-data)))
       ;; Mask and width now are both relative to rsh.  I.e., shift first, then mask/truncate.
       (delay (svar->delay var))
       (delay-msg (if (eql delay 0)
                      ""
                    (msg " (delay ~x0)" delay)))
       (val (svtv-chase-eval var phase))
       (shifted-val  (maybe-4vec-zero-ext width (4vec-shift-core (- (lnfix rsh)) val)))
       (mask (sparseint-val mask))
       (masked-val (4vec-bitand shifted-val (2vec mask)))
       (print-with-mask-mode (svtv-chase-data->print-with-mask-mode svtv-chase-data))
       (print-with-masked-val (case print-with-mask-mode
                                ((t) t)
                                ((nil) nil)
                                (t (and (not (2vec-p shifted-val))
                                        (2vec-p masked-val)))))
       (printed-val (if print-with-masked-val
                        masked-val
                      shifted-val))
       (first-lines (append (list (2col4vecline
                                   (msg "~@0 ~@1~@2"
                                        (if index (msg "~x0." index) "")
                                        name/range
                                        delay-msg)
                                   printed-val))
                            (2col4vec-maybe-line
                             print-with-masked-val
                             (if (eq print-with-mask-mode t)
                                 "(value masked due to MASK-ALWAYS setting -- ? for help)"
                               "(value masked to make it 2valued -- ? for help)")
                              nil)
                            (2col4vec-maybe-line (not (2vec-p val))
                                                 "  non-Boolean portion:"
                                                 (2vec (logxor (4vec->upper val) (4vec->lower val))))))
       (caremask-lines (list (2col4vecline "  caremask:" (2vec mask))))
       ((unless print-overrides)
        (append first-lines caremask-lines))

       ((mv override-mask override-val computed-val)
        (svtv-chase-eval-override var phase))
       (override-mask (maybe-loghead width (ash override-mask (- (lnfix rsh)))))
       (masked-override-mask (logand override-mask mask))
       ((when (eql masked-override-mask 0))
        (append first-lines caremask-lines))
       (override-val (maybe-4vec-zero-ext width (4vec-shift-core (- (lnfix rsh)) override-val)))
       (override-val (if print-with-masked-val
                         (4vec-bitand override-val (2vec masked-override-mask ))
                       override-val))
       (computed-val (maybe-4vec-zero-ext width (4vec-shift-core (- (lnfix rsh)) computed-val)))
       (computed-val (if print-with-masked-val
                         (4vec-bitand computed-val
                                      (2vec (logand mask (lognot override-mask))))
                       computed-val))

       (override-lines (list
                        (2col4vecline "Value results from an override --" nil)
                        (2col4vecline "  Override mask:" (2vec override-mask))
                        (2col4vecline "  Override val:"  override-val)
                        (2col4vecline "  Computed val:"  computed-val))))
    (append first-lines caremask-lines override-lines)))


(local (defthm len-equal-0
         (equal (equal (len x) 0)
                (not (consp x)))))

(define svtv-chase-print-signals ((index natp)
                                  (vars 4vmask-alist-p)
                                  (phase natp)
                                  (print-overrides)
                                  &key
                                  ((moddb moddb-ok) 'moddb)
                                  (svtv-chase-data 'svtv-chase-data))
  :guard (< (svtv-chase-data->modidx svtv-chase-data) (moddb->nmods moddb))
  :guard-hints (("goal" :in-theory (enable alist-keys))
                (and stable-under-simplificationp
                     '(:in-theory (enable svtv-chase-datap))))
  :returns (lines 2col4vecs-p)
  (if (atom vars)
      nil
    (if (mbt (consp (car vars)))
        (append (list (2col4vecline "----              -----              -----              -----              -----" nil))
                (svtv-chase-print-signal (lnfix index)
                                         (caar vars)
                                         phase
                                         0 (cdar vars)
                                         print-overrides)
                (svtv-chase-print-signals (1+ (lnfix index)) (cdr vars) phase print-overrides))
      (svtv-chase-print-signals (1+ (lnfix index)) (cdr vars)  phase print-overrides))))

      
                     
         
(local (defthm len-alist-keys-when-4vmask-alist-p
         (implies (4vmask-alist-p x)
                  (equal (len (alist-keys x))
                         (len x)))
         :hints(("Goal" :in-theory (enable alist-keys)))))



(define svtv-labelpair-p (x)
  (or (integerp x) ;; no label, just offset
      (symbolp x) ;; no offset, just label
      (and (consp x)
           (symbolp (car x))
           (consp (cdr x))
           (integerp (cadr x))
           (not (cddr x)))))

(define svtv-chase-phase-labelpair-aux ((phase natp)
                                        (phaselabels symbol-listp))
  ;; Scans through the phase labels and returns either the phase label at
  ;; phase, the last phase label before phase and the offset of phase from that
  ;; label, or NIL if no label was found at or before phase.
  :returns (labelpair svtv-labelpair-p
                      :hints(("Goal" :in-theory (enable svtv-labelpair-p))))
  (if (zp phase)
      (mbe :logic (acl2::symbol-fix (car phaselabels))
           :exec (car phaselabels))
    (if (car phaselabels)
        (or (svtv-chase-phase-labelpair-aux (1- phase) (cdr phaselabels))
            (list (mbe :logic (acl2::symbol-fix (car phaselabels))
                       :exec (car phaselabels))
                  phase))
      (svtv-chase-phase-labelpair-aux (1- phase) (cdr phaselabels)))))

(define svtv-chase-phase-labelpair ((phase integerp)
                                    (phaselabels symbol-listp))
  :returns (labelpair svtv-labelpair-p
                      :hints ((and stable-under-simplificationp
                                   '(:in-theory (enable svtv-labelpair-p)))))
  ;; Returns either:
  ;;  - the phase label exactly at phase,
  ;;  - the last phase label before phase and the offset of phase at that label,
  ;;  - phase itself if no labels before phase.
  (if (< (lifix phase) 0)
      (lifix phase)
    (or (svtv-chase-phase-labelpair-aux phase phaselabels)
        (lnfix phase))))

(define svtv-chase-labelpair-phase ((labelpair svtv-labelpair-p)
                                    (phaselabels symbol-listp))
  :prepwork ((local (in-theory (enable svtv-labelpair-p))))
  :returns (phase acl2::maybe-integerp :rule-classes :type-prescription)
  (b* (((when (integerp labelpair))
        labelpair)
       (name (if (consp labelpair)
                 (car labelpair)
               labelpair))
       (offset (if (consp labelpair)
                   (lifix (cadr labelpair))
                 0))
       (label-index (acl2::index-of name phaselabels)))
    (and label-index (+ label-index offset))))


    
(local (in-theory (disable nth update-nth)))









(define svtv-chase-signal ((var svar-p)
                           (phase integerp)
                           (rsh natp)
                           (mask 4vmask-p)
                           &key
                           (svtv-chase-data 'svtv-chase-data)
                           ((moddb moddb-ok) 'moddb))
  :guard (and ;; (svar-addr-p var)
              ;; (svarlist-addr-p (svex-alist-vars (debugdata->override-assigns debugdata)))
              ;; (svarlist-addr-p (svar-map-vars (debugdata->delays debugdata)))
              (< (svtv-chase-data->modidx svtv-chase-data) (moddb->nmods moddb)))
  :guard-hints ((and stable-under-simplificationp
                     '(:in-theory (enable svtv-chase-datap))))
  :returns (mv (type symbolp :rule-classes :type-prescription)
               (vars 4vmask-alist-p)
               (expr svex-p))
  (b* (((svtv-chase-data svtv-chase-data))
       ((mv var phase) (svtv-chase-normalize-var/phase var phase))
       (signal-lines (svtv-chase-print-signal nil var phase rsh mask t))
       (phase-line (list (2col4vecline
                          (msg "(Phase ~@0.)"
                               (b* ((pair (svtv-chase-phase-labelpair phase svtv-chase-data.phaselabels)))
                                 (if (equal pair phase)
                                     (msg "~x0" phase)
                                   (msg "~x0 = ~x1" pair phase))))
                          nil)))
       ((mv type vars expr)
        (svtv-chase-deps var phase rsh mask))
       (deps-lines
        (b* (((when (eq type :error))
              (list (2col4vecline "Error! Somehow this signal wasn't what we expected." nil)))
             ((when (eq type :input))
              (list (2col4vecline "Primary input." nil)))
             ((when (eq type :initst))
              (list (2col4vecline "Initial state." nil)))
             ((when (eq type :prevst))
              (cons (2col4vecline "Previous state var." nil)
                    (svtv-chase-print-signals 0 vars phase svtv-chase-data.print-overrides-mode))))
          (cons (2col4vecline "Internal signal; dependencies:" nil)
                (svtv-chase-print-signals 0 vars phase svtv-chase-data.print-overrides-mode))))
       (last-line (list (2col4vecline "================================================================================" nil)))
       (msg (print-2col4vecs
             (append signal-lines phase-line deps-lines last-line))))
    (cw! "~@0" msg)
    (mv type vars expr))
  ///
  ;; (defret svarlist-addr-p-of-<fn>
  ;;   (implies (and (svar-addr-p var)
  ;;                 (svarlist-addr-p (svex-alist-vars (debugdata->override-assigns debugdata)))
  ;;                 (svarlist-addr-p (svar-map-vars (debugdata->delays debugdata))))
  ;;            (svarlist-addr-p (alist-keys vars)))
  ;;   :hints(("Goal" :in-theory (enable alist-keys))))

  

  ;; (defret svarlist-addr-p-expr-of-<fn>
  ;;   (implies (and (svar-addr-p var)
  ;;                 (svarlist-addr-p (svex-alist-vars (debugdata->override-assigns debugdata)))
  ;;                 (svarlist-addr-p (svar-map-vars (debugdata->delays debugdata))))
  ;;            (svarlist-addr-p (svex-vars expr)))
  ;;   :hints(("Goal" :in-theory (enable alist-keys))))
  )

;; (define svar-addr-p! (x)
;;   :enabled t
;;   (and (svar-p x)
;;        (svar-addr-p x)))

;; (define 4vmask-alist-addr-p! (x)
;;   :enabled t
;;   (and (4vmask-alist-p x)
;;        (svarlist-addr-p (alist-keys x))))

;; (define svex-addr-p! (x)
;;   :enabled t
;;   (and (svex-p x)
;;        (svarlist-addr-p (svex-vars x))))


(define svtv-chase-signal-data ((pos chase-position-p)
                                &key
                                ((moddb moddb-ok) 'moddb)
                                (svtv-chase-data 'svtv-chase-data))
  :guard (and ;; (chase-position-addr-p pos)
              ;; (svarlist-addr-p (svex-alist-vars (debugdata->override-assigns debugdata)))
              ;; (svarlist-addr-p (svar-map-vars (debugdata->delays debugdata)))
              (< (svtv-chase-data->modidx svtv-chase-data) (moddb->nmods moddb)))
  :guard-hints (("goal" :in-theory (enable svtv-chase-datap
                                           ;; chase-position-addr-p
                                           ;; chase-stack-addr-p
                                           )))
  :returns (new-svtv-chase-data)
  (b* (((chase-position pos))
       ((mv type vars expr)
        (svtv-chase-signal (make-svar :name (make-address :path pos.path))
                           pos.phase pos.rsh pos.mask))
       ((when (eq type :error))
        (cw! "[Error -- discrepancy between stored updates and assignments!]~%")
        svtv-chase-data)
       (svtv-chase-data (set-svtv-chase-data->stack (cons pos (svtv-chase-data->stack svtv-chase-data))
                                            svtv-chase-data))
       (svtv-chase-data (set-svtv-chase-data->sigtype type svtv-chase-data))
       (svtv-chase-data (set-svtv-chase-data->vars vars svtv-chase-data))
       (svtv-chase-data (set-svtv-chase-data->expr expr svtv-chase-data))
       ;; (svtv-chase-data (set-svtv-chase-data->new-phase new-phase svtv-chase-data))
       )
    svtv-chase-data)
  ///
  (defret nth-of-<fn>
    (implies (not (member-equal (nfix n) (list *svtv-chase-data->stack*
                                               *svtv-chase-data->sigtype*
                                               *svtv-chase-data->vars*
                                               *svtv-chase-data->expr*)))
             (equal (nth n new-svtv-chase-data)
                    (nth n svtv-chase-data)))))


(define svtv-chase-range ((pos chase-position-p)
                          (msb integerp)
                          (lsb integerp)
                          &key
                          ((moddb moddb-ok) 'moddb)
                          (svtv-chase-data 'svtv-chase-data))
  :guard (and ;; (chase-position-addr-p pos)
              ;; (svarlist-addr-p (svex-alist-vars (debugdata->override-assigns debugdata)))
              ;; (svarlist-addr-p (svar-map-vars (debugdata->delays debugdata)))
              (< (svtv-chase-data->modidx svtv-chase-data) (moddb->nmods moddb)))
  :guard-hints ((and stable-under-simplificationp
                     '(:in-theory (enable ;; chase-position-addr-p
                                   ;; svar-addr-p
                                   svtv-chase-datap))))
  :returns (new-svtv-chase-data)
  :prepwork ((local (in-theory (disable logmask not))))
  (b* ((modidx (svtv-chase-data->modidx svtv-chase-data))
       ((chase-position pos))
       ;; (path (address->path (svar->name pos.var)))
       ((mv err wire & &) (moddb-path->wireidx/decl pos.path modidx moddb))
       ((when err)
        (cw! "[ERROR finding wire ~s0]: ~@1~%" (path->string-top pos.path) err)
        svtv-chase-data)
       ((wire wire))
       (msb (lifix msb))
       (lsb (lifix lsb))
       (wire-lsb (if wire.revp
                     (+ wire.low-idx (- wire.width 1))
                   wire.low-idx))
       (wire-msb (if wire.revp
                     wire.low-idx
                   (+ wire.low-idx (- wire.width 1))))
       ((unless (if wire.revp
                    (and (<= wire-msb msb) (<= msb lsb) (<= lsb wire-lsb))
                  (and (<= wire-lsb lsb) (<= lsb msb) (<= msb wire-msb))))
        (cw! "Bad range for ~s0: declared range is [~x1:~x2]~%"
             (path->string-top pos.path) wire-msb wire-lsb)
        svtv-chase-data)
       (width (if wire.revp
                  (+ 1 (- lsb msb))
                (+ 1 (- msb lsb))))
       (rsh (if wire.revp (- wire-lsb lsb) (- lsb wire-lsb)))
       (mask (logmask width))
       (new-pos (change-chase-position pos
                                       :rsh rsh
                                       :mask (int-to-sparseint mask))))
    (svtv-chase-signal-data new-pos))
  ///
  (defret nth-of-<fn>
    (implies (not (member-equal (nfix n) (list *svtv-chase-data->stack*
                                               *svtv-chase-data->sigtype*
                                               *svtv-chase-data->vars*
                                               *svtv-chase-data->expr*)))
             (equal (nth n new-svtv-chase-data)
                    (nth n svtv-chase-data)))))

;; (local
;;  (defsection lhs-addr-p-of-svtv-wire->lhs

;;    (defret lhs-addr-p-of-svtv-1wire->lhs
;;      (implies (svarlist-addr-p (aliases-vars aliases))
;;               (svarlist-addr-p (lhs-vars lhs)))
;;      :hints(("Goal" :in-theory (enable svtv-1wire->lhs
;;                                        )))
;;      :fn svtv-1wire->lhs)

;;    (local (defthm member-lhs-vars-of-append
;;             (implies (and (not (member v (lhs-vars a)))
;;                           (not (member v (lhs-vars b))))
;;                      (not (member v (lhs-vars (append a b )))))
;;             :hints(("Goal" :in-theory (enable lhs-vars)))))

;;    (defret lhs-addr-p-of-svtv-concat->lhs
;;      (implies (svarlist-addr-p (aliases-vars aliases))
;;               (svarlist-addr-p (lhs-vars lhs)))
;;      :hints(("Goal" :in-theory (enable svtv-concat->lhs
;;                                        )))
;;      :fn svtv-concat->lhs)

;;    (defret lhs-addr-p-of-svtv-wire->lhs
;;      (implies (svarlist-addr-p (aliases-vars aliases))
;;               (svarlist-addr-p (lhs-vars lhs)))
;;      :hints(("Goal" :in-theory (enable svtv-wire->lhs)))
;;      :fn svtv-wire->lhs)))


;; (local (include-book "centaur/bitops/ihsext-basics" :dir :system
(local (in-theory (disable logmask)))

(define svtv-chase-goto-lhs ((lhs lhs-p)
                             (phase natp)
                             (debug-source-obj)
                             &key
                             ((moddb moddb-ok) 'moddb)
                             (svtv-chase-data 'svtv-chase-data))
  :guard (and ;; (svarlist-addr-p (svex-alist-vars (debugdata->override-assigns debugdata)))
              ;; (svarlist-addr-p (svar-map-vars (debugdata->delays debugdata)))
              (< (svtv-chase-data->modidx svtv-chase-data) (moddb->nmods moddb))
              ;; (svarlist-addr-p (aliases-vars aliases))
              )
  :guard-hints (("goal" :in-theory (e/d (svtv-mod-alias-guard
                                           ;; chase-position-addr-p
                                           svtv-chase-datap)
                                        (logmask))
                 :do-not-induct t))
  ;; :prepwork ((local (defthm svar-addr-p-of-lhatom-var->name
  ;;                     (implies (and (lhatom-case x :var)
  ;;                                   (svarlist-addr-p (lhatom-vars x)))
  ;;                              (svar-addr-p (lhatom-var->name x)))
  ;;                     :hints(("Goal" :in-theory (enable lhatom-vars)))))
  ;;            (local (defthm member-vars-of-lhrange->atom
  ;;                     (implies (and (not (member v (lhs-vars x)))
  ;;                                   (consp x))
  ;;                              (not (member v (lhatom-vars (lhrange->atom (car x))))))
  ;;                     :hints(("Goal" :in-theory (enable lhs-vars)))))
  ;;            (local (in-theory (disable lhs-vars-when-consp))))
  :guard-debug t
  :returns (new-svtv-chase-data)
  (b* (((when (atom lhs))
        (cw! "Error interpreting name: ~x0~%" debug-source-obj)
        svtv-chase-data)
       ((when (consp (cdr lhs)))
        (cw! "Error interpreting name: ~x0 was a concatenation~%" debug-source-obj)
        svtv-chase-data)
       ((lhrange lhrange) (car lhs))
       ((unless (lhatom-case lhrange.atom :var))
        (cw! "Error interpreting name: ~x0 had no variable component~%" debug-source-obj)
        svtv-chase-data)
       ((lhatom-var lhrange.atom))
       ((svar lhrange.atom.name))
       ((unless (address-p lhrange.atom.name.name))
        (cw! "Error interpreting name: ~x0 produced a variable that was not an address~%" debug-source-obj)
        svtv-chase-data)
       (pos (make-chase-position :path (address->path lhrange.atom.name.name)
                                 :phase phase
                                 :rsh lhrange.atom.rsh
                                 :mask (int-to-sparseint (logmask lhrange.w)))))
    (svtv-chase-signal-data pos))
  ///
  (defret nth-of-<fn>
    (implies (not (member-equal (nfix n) (list *svtv-chase-data->stack*
                                               *svtv-chase-data->sigtype*
                                               *svtv-chase-data->vars*
                                               *svtv-chase-data->expr*)))
             (equal (nth n new-svtv-chase-data)
                    (nth n svtv-chase-data)))))
       

(define svtv-chase-goto ((str stringp)
                         (labelpair svtv-labelpair-p)
                         &key
                         ((moddb moddb-ok) 'moddb)
                         (aliases 'aliases)
                         (svtv-chase-data 'svtv-chase-data))
  :guard (and (< (svtv-chase-data->modidx svtv-chase-data) (moddb->nmods moddb))
              (<= (moddb-mod-totalwires (svtv-chase-data->modidx svtv-chase-data) moddb)
                  (aliass-length aliases)))
  :guard-hints (("goal" :in-theory (e/d (svtv-mod-alias-guard
                                           ;; chase-position-addr-p
                                           svtv-chase-datap)
                                        (logmask))
                 :do-not-induct t))
  :guard-debug t
  :returns (new-svtv-chase-data)
  (b* (((mv err lhs) (svtv-wire->lhs str (svtv-chase-data->modidx svtv-chase-data) moddb aliases))
       ((when err)
        (cw! "Error interpreting name: ~s0~%" str)
        svtv-chase-data)
       (phase (svtv-chase-labelpair-phase labelpair (svtv-chase-data->phaselabels svtv-chase-data)))
       ((unless phase)
        (cw! "Error interpreting phase: ~x0 -- label not found~%" labelpair)
        svtv-chase-data)
       ((unless (<= 0 phase))
        (cw! "Error interpreting phase: ~x0 -- normalized to negative value: ~x1~%" labelpair phase)
        svtv-chase-data))
    (svtv-chase-goto-lhs lhs phase str))
  ///
  (defret nth-of-<fn>
    (implies (not (member-equal (nfix n) (list *svtv-chase-data->stack*
                                               *svtv-chase-data->sigtype*
                                               *svtv-chase-data->vars*
                                               *svtv-chase-data->expr*)))
             (equal (nth n new-svtv-chase-data)
                    (nth n svtv-chase-data)))))

(define svtv-chase-goto-output ((name)
                                &key
                                ((moddb moddb-ok) 'moddb)
                                (svtv-chase-data 'svtv-chase-data))
  :guard (and (< (svtv-chase-data->modidx svtv-chase-data) (moddb->nmods moddb)))
  :guard-hints (("goal" :in-theory (e/d (svtv-mod-alias-guard
                                           ;; chase-position-addr-p
                                           svtv-chase-datap)
                                        (logmask))
                 :do-not-induct t))
  :guard-debug t
  :returns (new-svtv-chase-data)
  (b* (((svtv-chase-data svtv-chase-data))
       (probe? (hons-assoc-equal name svtv-chase-data.probes))
       ((unless probe?)
        (cw! "Error: no output named ~x0~%" name)
        svtv-chase-data)
       ((svtv-probe probe) (cdr probe?))
       (lhs? (hons-assoc-equal probe.signal svtv-chase-data.namemap))
       ((unless lhs?)
        (cw! "Error: found output named ~x0 pointing to signal ~x1 but no such entry in namemap~%"
             name probe.signal)
        svtv-chase-data)
       (lhs (cdr lhs?)))
    (svtv-chase-goto-lhs lhs probe.time name))
  ///
  (defret nth-of-<fn>
    (implies (not (member-equal (nfix n) (list *svtv-chase-data->stack*
                                               *svtv-chase-data->sigtype*
                                               *svtv-chase-data->vars*
                                               *svtv-chase-data->expr*)))
             (equal (nth n new-svtv-chase-data)
                    (nth n svtv-chase-data)))))
       

(define svtv-chase-print (&key
                          ((moddb moddb-ok) 'moddb)
                          (svtv-chase-data 'svtv-chase-data))
  :guard (and (< (svtv-chase-data->modidx svtv-chase-data) (moddb->nmods moddb)))
  :returns new-svtv-chase-data
  :guard-hints ((and stable-under-simplificationp
                     '(:in-theory (enable svtv-chase-datap)
                       :do-not-induct t))
                ;; (and stable-under-simplificationp
                ;;      '(:in-theory (enable chase-position-addr-p)))
                )
  (b* ((stack (svtv-chase-data->stack svtv-chase-data))
       ((unless (consp stack))
        (cw! "Empty stack! Use (G \"path\" phase) to choose a signal, ? for more options.~%")
        svtv-chase-data)
       (pos (car stack))
       (svtv-chase-data (set-svtv-chase-data->stack (cdr stack) svtv-chase-data))
       (svtv-chase-data (svtv-chase-signal-data pos)))
    svtv-chase-data)
  ///
  (defmacro svtv-chase-print! (&rest args)
    `(b* ((svtv-chase-data (svtv-chase-print . ,args)))
       (mv nil svtv-chase-data state)))

  (defret nth-of-<fn>
    (implies (not (member-equal (nfix n) (list *svtv-chase-data->stack*
                                               *svtv-chase-data->sigtype*
                                               *svtv-chase-data->vars*
                                               *svtv-chase-data->expr*)))
             (equal (nth n new-svtv-chase-data)
                    (nth n svtv-chase-data)))))

(defconst *chase-usage*
  "
What you can enter at the SVTV-CHASE prompt:

 ?                  prints this help message

 X                  Exit the chase read-eval-print loop.

 P                  prints the current state, including the next signal choices

 (G \"path\" phase) Go to the signal named by the given path at the given phase.
                    The phase may be specified as a natural number (offset), 
                    a phase label from the defsvtv form, or a combination
                    (label num), meaning the numth phase after label.

 (O name)           Go to the signal/phase corresponding to the named pipeline output.

 (R MSB LSB)        Select the given MSB:LSB range of the current signal

 Natural number     Select the given choice of next signal
 B                  Go back to the previous signal on the stack.

 EXPR               Print the assignment for the current signal.
 (EXPR N)           Print the assignment expression, limiting nesting depth to N.

 SMARTP             Toggle data-aware dependency reduction feature
                    (reduces the number of irrelevant signals listed).
                    On by default.

 (EV form)          Evaluates form using simple-translate-and-eval 
                    and prints the result.  You need to set up an attachment
                    to do this, which you can do by running
                    (sv::setup-ev-for-chase) in the ACL2 loop.  You can undo this
                    with (sv::unsetup-ev-for-chase).

 MASK-ALWAYS
 MASK-NEVER
 MASK-DEFAULT       Affects whether signal values are ANDed with the caremask before
                    printing.  The default is to only AND the value with the mask if
                    the unmasked value is not 2valued and the masked value is 2valued.
                    The -always and -never settings change this to always/never 
                    (respectively) AND the value with the mask.

 OVERRIDES-VERBOSE
 OVERRIDES-DEFAULT  Affects whether the derivation of signal values from overrides is
                    printed for only the current signal (default) or for all
                    dependencies as well (verbose).
")

(defmacro setup-ev-for-chase ()
  '(progn
     (defttag trans)
     (defattach (simple-translate-and-eval-logic acl2::simple-translate-and-eval-cmp)
       :skip-checks t)))

(defmacro unsetup-ev-for-chase ()
  '(progn
     (defttag nil)
     (defattach (simple-translate-and-eval-logic nil))))

;; (local (defthm chase-position-addr-p-car-when-chase-stack-addr-p
;;          (implies (and (svtv-chase-data->stack-addr-p x)
;;                        (consp x))
;;                   (svtv-chase-data->position-addr-p (car x)))
;;          :hints(("Goal" :in-theory (enable chase-stack-addr-p)))))

;; (local (defthm chase-stack-addr-p-cdr-when-chase-stack-addr-p
;;          (implies (svtv-chase-data->stack-addr-p x)
;;                   (svtv-chase-data->stack-addr-p (cdr x)))
;;          :hints(("Goal" :in-theory (enable chase-stack-addr-p)))))


(local (defthm nth-when-4vmask-alist-p
         (implies (and (4vmask-alist-p x)
                       (< (nfix n) (len x)))
                  (and (consp (nth n x))
                       (svar-p (car (nth n x)))
                       (sparseint-p (cdr (nth n x)))))
         :hints(("Goal" :in-theory (enable nth)))))

;; (local (defthm nth-svar-addr-p-when-4vmask-alist-p
;;          (implies (and (4vmask-alist-p x)
;;                        (svarlist-addr-p (alist-keys x))
;;                        (< (nfix n) (len x)))
;;                   (svar-addr-p (car (nth n x))))
;;          :hints(("Goal" :in-theory (enable nth alist-keys)))))

(local (in-theory (disable read-object
                           open-input-channel-p1
                           member)))

(include-book "std/io/file-measure" :dir :system)
(local (include-book "std/io/open-channels" :dir :system))
(local (in-theory (disable file-measure)))

(verify-termination evisc-tuple)
(verify-guards evisc-tuple)


(encapsulate
  (((simple-translate-and-eval-logic
     * * * * * * state * * *) => (mv * *)
    :formals (x alist ok-stobj-names msg ctx wrld state aok safe-mode gc-off)
    :guard t))
  (set-ignore-ok t)
  (set-irrelevant-formals-ok t)
  (local (defun simple-translate-and-eval-logic (x alist ok-stobj-names msg ctx wrld state aok safe-mode gc-off)
           (declare (xargs :stobjs state))
           (mv nil nil))))


(local (in-theory (disable w)))

(local (defthm w-of-read-object
         (equal (w (mv-nth 2 (read-object channel state)))
                (w state))
         :hints(("Goal" :in-theory (enable w read-object
                                           ;; Matt K. addition for 5/8/2023 change to
                                           ;; read-object to call iprint-oracle-updates:
                                           read-acl2-oracle update-acl2-oracle)))))

(define svtv-chase-rep (&key
                        ((moddb moddb-ok) 'moddb)
                        (svtv-chase-data 'svtv-chase-data)
                        (aliases 'aliases)
                        (state 'state))
  :guard (and (open-input-channel-p *standard-oi* :object state)
              ;; (svarlist-addr-p (svex-alist-vars (debugdata->override-assigns debugdata)))
              ;; (svarlist-addr-p (svar-map-vars (debugdata->delays debugdata)))
              (< (svtv-chase-data->modidx svtv-chase-data) (moddb->nmods moddb))
              (<= (moddb-mod-totalwires (svtv-chase-data->modidx svtv-chase-data) moddb)
                  (aliass-length aliases))
              ;; (svarlist-addr-p (aliases-vars aliases))
              )
  :guard-hints ((and stable-under-simplificationp
                     '(:in-theory (enable svtv-chase-datap)
                       :do-not-induct t)
                ;; (and stable-under-simplificationp
                ;;      '(:in-theory (enable chase-position-addr-p)))
                ))
  :returns (mv exitp new-svtv-chase-data new-state)
  (b* ((- (cw! "SVTV-CHASE > "))
       ((mv err obj state) (read-object *standard-oi* state))
       ((when err)
        (mv t svtv-chase-data state))
       ((when (natp obj))
        (b* ((vars (svtv-chase-data->vars svtv-chase-data))
             (stack (svtv-chase-data->stack svtv-chase-data))
             ((unless (consp stack))
              (cw! "Empty stack! Use (G \"path\" phase) to choose a signal, ? for more options.~%")
              (mv nil svtv-chase-data state))
             ((chase-position pos) (car stack))
             ((unless (< obj (len vars)))
              (cw "Out of range! Enter P to print current state, ? for more options.~%")
              (mv nil svtv-chase-data state))
             ((cons new-var new-mask) (nth obj vars))
             ((mv rsh mask) (svtv-chase-normalize-mask 0 new-mask))
             ((mv new-var new-phase) (svtv-chase-normalize-var/phase new-var pos.phase))
             (name (svar->name new-var))
             ((unless (address-p name))
              (cw! "The chosen signal isn't an address, so it must be an ~
                    auxiliary variable supporting an override.~%Enter P to ~
                    print current state, ? for more options.~%")
              (mv nil svtv-chase-data state))
             (svtv-chase-data (svtv-chase-signal-data
                               (make-chase-position
                                :path (address->path name)
                                :phase (- new-phase (svar->delay new-var))
                                :rsh rsh :mask mask))))
          (mv nil svtv-chase-data state)))
       ((when (symbolp obj))
        (b* ((objname (symbol-name obj))
             ((when (equal objname "?"))
              (cw! *chase-usage*)
              (mv nil svtv-chase-data state))
             ((when (equal objname "P"))
              (svtv-chase-print!))
             ((when (equal objname "EXPR"))
              (cw! "~x0~%" (svtv-chase-data->expr svtv-chase-data))
              (mv nil svtv-chase-data state))
             ;; Too bad, walkabout isn't in logic mode
             ;; ((when (equal objname "WALK"))
             ;;  (b* (((mv ?err ?val state) (acl2::walkabout (chase-expr svtv-chase-data) state)))
             ;;    (mv nil svtv-chase-data state)))
             ((when (equal objname "B"))
              (b* ((stack (svtv-chase-data->stack svtv-chase-data))
                   ((unless (and (consp stack)
                                 (consp (cdr stack))))
                    (cw! "At end of stack!~%")
                    (mv nil svtv-chase-data state))
                   (svtv-chase-data (set-svtv-chase-data->stack (cdr stack) svtv-chase-data)))
                (svtv-chase-print!)))
             ((when (equal objname "X"))
              (mv t svtv-chase-data state))
             ((when (equal objname "SMARTP"))
              (b* ((smartp (svtv-chase-data->smartp svtv-chase-data))
                   (new-smartp (not smartp))
                   (svtv-chase-data (set-svtv-chase-data->smartp new-smartp svtv-chase-data)))
                (cw! "Turned data-aware dependency reduction ~s0.~%"
                     (if new-smartp "on" "off"))
                (svtv-chase-print!)))

             ((when (equal objname "MASK-ALWAYS"))
              (b* ((svtv-chase-data (set-svtv-chase-data->print-with-mask-mode t svtv-chase-data)))
                (cw! "Changed mask mode: always apply caremask to signal values~%")
                (mv nil svtv-chase-data state)))
             ((when (equal objname "MASK-NEVER"))
              (b* ((svtv-chase-data (set-svtv-chase-data->print-with-mask-mode nil svtv-chase-data)))
                (cw! "Changed mask mode: never apply caremask to signal values~%")
                (mv nil svtv-chase-data state)))
             ((when (equal objname "MASK-DEFAULT"))
              (b* ((svtv-chase-data (set-svtv-chase-data->print-with-mask-mode :default svtv-chase-data)))
                (cw! "Changed mask mode: apply caremask to signal values if it results in a 2vec~%")
                (mv nil svtv-chase-data state)))
             ((when (equal objname "OVERRIDES-VERBOSE"))
              (b* ((svtv-chase-data (set-svtv-chase-data->print-overrides-mode t svtv-chase-data)))
                (cw! "Changed override mode: print overrides for dependencies~%")
                (mv nil svtv-chase-data state)))
             ((when (equal objname "OVERRIDES-DEFAULT"))
              (b* ((svtv-chase-data (set-svtv-chase-data->print-overrides-mode nil svtv-chase-data)))
                (cw! "Changed override mode: print overrides only for current signal~%")
                (mv nil svtv-chase-data state))))
          (cw! "Error -- unrecognized directive: ~x0~%Type ? for allowed commands.~%" obj)
          (mv nil svtv-chase-data state)))
       ((when (and (consp obj)
                   (symbolp (car obj))))
        (b* ((objname (symbol-name (car obj)))
             (args (cdr obj))
             ((when (equal objname "R"))
              (b* (((unless (and (consp args)
                                 (integerp (car args))
                                 (consp (cdr args))
                                 (integerp (cadr args))
                                 (not (cddr args))))
                    (cw! "R directive must be of the form (R MSB LSB) where MSB and LSB are integers.  ? for more options.~%")
                    (mv nil svtv-chase-data state))
                   (stack (svtv-chase-data->stack svtv-chase-data))
                   ((unless (consp stack))
                    (cw! "Empty stack! Use (G \"path\") to choose a signal, ? for more options.~%")
                    (mv nil svtv-chase-data state))
                   (pos (car stack))
                   (svtv-chase-data (svtv-chase-range pos (car args) (cadr args))))
                (mv nil svtv-chase-data state)))
             ((when (equal objname "G"))
              (b* (((unless (and (consp args)
                                 (stringp (car args))
                                 (consp (cdr args))
                                 (svtv-labelpair-p (cadr args))
                                 (not (cddr args))))
                    (cw! "G directive must be of the form (G \"path\" phase) ~
                          where the first argument is a string and the second ~
                          is either a natural number offset, a phase label ~
                          (symbol), or a list (label offset).~%")
                    (mv nil svtv-chase-data state))
                   (svtv-chase-data (svtv-chase-goto (car args) (cadr args))))
                (mv nil svtv-chase-data state)))
             ((when (equal objname "O"))
              (b* (((unless (and (consp args)
                                 (not (cdr args))))
                    (cw! "O directive must be of the form (O name).~%")
                    (mv nil svtv-chase-data state))
                   (svtv-chase-data (svtv-chase-goto-output (car args))))
                (mv nil svtv-chase-data state)))
             ((when (equal objname "EXPR"))
              (b* (((unless (and (consp args)
                                 (acl2::maybe-natp (car args))
                                 (not (cdr args))))
                    (cw! "EXPR directive must be of the form (EXPR depth).~%")
                    (mv nil svtv-chase-data state)))
                (acl2::fmt-to-comment-window! "~x0~%"
                                              `((#\0 . ,(svtv-chase-data->expr svtv-chase-data)))
                                              0 (evisc-tuple (car args) nil nil nil) nil)
                (mv nil svtv-chase-data state)))
             ((when (equal objname "EV"))
              (b* (((unless (and (consp args)
                                 (not (cdr args))))
                    (cw! "EV directive must be of the form (EV term).~%")
                    (mv nil svtv-chase-data state))
                   (attachment (fgetprop 'simple-translate-and-eval-logic 'acl2::attachment nil (w state)))
                   ((unless (and attachment
                                 (alistp attachment)
                                 (eq (cdr (assoc-eq 'simple-translate-and-eval-logic attachment))
                                     'acl2::simple-translate-and-eval-cmp)))
                    (cw! "In order to use EV you must set ~x0 as the ~
                          attachment for ~x1, as in the following ~
                          form:~%~x2~%Note that to (mostly) undo this you may ~
                          do:~%~x3~%"
                         'acl2::simple-translate-and-eval-cmp
                         'simple-translate-and-eval-logic
                         '(setup-ev-for-chase)
                         '(unsetup-ev-for-chase))
                    (mv nil svtv-chase-data state))
                   ((mv err term-dot-val)
                    (simple-translate-and-eval-logic (car args) nil nil "The argument to EV"
                                                     'svtv-chase-rep (w state) state t nil nil))
                   ((when (or err (not (consp term-dot-val))))
                    (cw! "Failed to evaluate: ~@0~%" term-dot-val)
                    (mv nil svtv-chase-data state)))
                (cw! "~x0~%" (cdr term-dot-val))
                (mv nil svtv-chase-data state))))
          (cw! "Error -- unrecognized directive: ~x0~%Type ? for allowed commands.~%" obj)
          (mv nil svtv-chase-data state))))
    (cw! "Error -- unrecognized directive: ~x0~%Type ? for allowed commands.~%" obj)
    (mv nil svtv-chase-data state))
  ///
  (defret file-measure-of-svtv-chase-rep-weak
    (<= (file-measure *standard-oi* new-state)
        (file-measure *standard-oi* state))
    :rule-classes :linear)

  (defret file-measure-of-svtv-chase-rep-strong
    (implies (not exitp)
             (< (file-measure *standard-oi* new-state)
                (file-measure *standard-oi* state)))
    :rule-classes :linear)

  (defret open-input-channel-p1-of-<fn>
    (implies (open-input-channel-p1 *standard-oi* :object state)
             (open-input-channel-p1 *standard-oi* :object new-state)))
  
  (defret nth-of-<fn>
    (implies (not (member-equal (nfix n) (list *svtv-chase-data->smartp*
                                               *svtv-chase-data->stack*
                                               *svtv-chase-data->sigtype*
                                               *svtv-chase-data->vars*
                                               *svtv-chase-data->expr*
                                               *svtv-chase-data->print-with-mask-mode*
                                               *svtv-chase-data->print-overrides-mode*)))
             (equal (nth n new-svtv-chase-data)
                    (nth n svtv-chase-data)))
    :hints(("Goal" :in-theory (enable member-equal)))))

  

(define svtv-chase-repl1 (&key
                         ((moddb moddb-ok) 'moddb)
                         (aliases 'aliases)
                         (svtv-chase-data 'svtv-chase-data)
                         (state 'state))
  :guard (and (open-input-channel-p *standard-oi* :object state)
              ;; (svarlist-addr-p (svexlist-collect-vars (svex-alist-vals (debugdata->override-assigns debugdata))))
              ;; (svarlist-addr-p (svar-map-vars (debugdata->delays debugdata)))
              (< (svtv-chase-data->modidx svtv-chase-data) (moddb->nmods moddb))
              (<= (moddb-mod-totalwires (svtv-chase-data->modidx svtv-chase-data) moddb)
                  (aliass-length aliases))
              ;; (svarlist-addr-p (aliases-vars aliases))
              )
  :guard-hints ((and stable-under-simplificationp
                     '(:in-theory (enable svtv-chase-datap)
                       :do-not-induct t)))
  :returns (mv new-svtv-chase-data new-state)
  :measure (file-measure *standard-oi* state)
  :parents (svtv-chase)
  :short "Re-enter the @(see svtv-chase) read-eval-print loop, with no change to the environment or SVTV."
  (b* (((mv exitp svtv-chase-data state) (svtv-chase-rep))
       ((when exitp)
        (cw! "~%Exiting SVTV-CHASE.  You may execute ~x0 to re-enter or ~x1 ~
              to change the simulation inputs.~%"
             '(svtv-chase-repl) '(svtv-chase-update env))
        (mv svtv-chase-data state)))
    (svtv-chase-repl1))

  ///
  (defret nth-of-<fn>
    (implies (not (member-equal (nfix n) (list *svtv-chase-data->smartp*
                                               *svtv-chase-data->stack*
                                               *svtv-chase-data->sigtype*
                                               *svtv-chase-data->vars*
                                               *svtv-chase-data->expr*
                                               *svtv-chase-data->print-with-mask-mode*
                                               *svtv-chase-data->print-overrides-mode*)))
             (equal (nth n new-svtv-chase-data)
                    (nth n svtv-chase-data)))))



(verify-termination fmt-hard-right-margin)
(verify-termination fmt-soft-right-margin)


(local (defthm open-input-channel-p1-of-put-global
         (equal (open-input-channel-p1 channel type (put-global key val state))
                (open-input-channel-p1 channel type state))
         :hints(("Goal" :in-theory (enable open-input-channel-p1
                                           open-input-channels
                                           put-global
                                           update-global-table)))))

(local (in-theory (disable put-global)))

(define svtv-chase-repl (&key
                         ((moddb moddb-ok) 'moddb)
                         (aliases 'aliases)
                         (svtv-chase-data 'svtv-chase-data)
                         (state 'state))
  :guard (and (open-input-channel-p *standard-oi* :object state)
              (< (svtv-chase-data->modidx svtv-chase-data) (moddb->nmods moddb))
              (<= (moddb-mod-totalwires (svtv-chase-data->modidx svtv-chase-data) moddb)
                  (aliass-length aliases)))
  :prepwork ((local (in-theory (disable nth))))
  :guard-hints ((and stable-under-simplificationp
                     '(:in-theory (enable svtv-chase-datap)
                       :do-not-induct t)))
  :returns (mv new-svtv-chase-data new-state)

  ;; Just wraps svtv-chase-repl1 with a setting of the fmt margins.
  (b* ((hard (pos-fix (and (boundp-global 'fmt-hard-right-margin state)
                           (f-get-global 'fmt-hard-right-margin state))))
       (soft (pos-fix (and (boundp-global 'fmt-soft-right-margin state)
                           (f-get-global 'fmt-soft-right-margin state))))
       (state (set-fmt-hard-right-margin 200 state))
       (state (set-fmt-soft-right-margin 150 state))
       ((mv svtv-chase-data state) (svtv-chase-repl1))
       (state (set-fmt-soft-right-margin soft state))
       (state (set-fmt-hard-right-margin hard state)))
    (mv svtv-chase-data state))
  ///
  (defret nth-of-<fn>
    (implies (not (member-equal (nfix n) (list *svtv-chase-data->smartp*
                                               *svtv-chase-data->stack*
                                               *svtv-chase-data->sigtype*
                                               *svtv-chase-data->vars*
                                               *svtv-chase-data->expr*
                                               *svtv-chase-data->print-with-mask-mode*
                                               *svtv-chase-data->print-overrides-mode*)))
             (equal (nth n new-svtv-chase-data)
                    (nth n svtv-chase-data)))))

